<!--
	Based on the NPF variable offered by Tumblr.
	https://github.com/tumblr/docs/blob/master/npf-spec.md
-->
<!DOCTYPE html>
<html lang="en" class="{select:Default palette}">

<head>
	{MobileAppHeaders}
	<meta charset="utf-8">
	<title>{Title}{block:TagPage} ({lang:TagResultCount posts tagged Tag}){/block:TagPage}{block:SearchPage} ({lang:SearchResultCount results for SearchQuery}{block:NoSearchResults}{lang:No results for SearchQuery}{/block:NoSearchResults}){/block:SearchPage}{block:PermalinkPage}{block:PostSummary} — {PostSummary}{/block:PostSummary}{/block:PermalinkPage}</title>
	<meta name="description" content="{MetaDescription}">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="theme-color" content="#35465D">
	<link rel="shortcut icon" href="{Favicon}">
	<link rel="apple-touch-icon-precomposed" href="{PortraitURL-128}">
	<link rel="alternate" type="application/rss+xml" href="{RSS}">{block:IfSyntaxHighlighting}
	<link rel="stylesheet" href="https://static.tumblr.com/ehm1tdz/2VWnye81h/tumblr-highlightjs.css">
	{/block:IfSyntaxHighlighting}
	{PostTypographyStyles}

	{block:Hidden}
	<!-- #region Custom variables -->
	<!-- Color options -->
	<meta name="color:Page background" content="#f9fbfd">
	<meta name="color:Post background" content="#ffffff">
	<meta name="color:Text" content="#000000">
	<meta name="color:Accent" content="#1967d2">
	<!-- Alternate palette -->
	<meta name="if:Palette toggle" content="1">
	<meta name="select:Default palette" content="" title="Original">
	<meta name="select:Default palette" content="alt" title="Alternate">
	<meta name="color:ALT Page background" content="#202124">
	<meta name="color:ALT Post background" content="#303134">
	<meta name="color:ALT Text" content="#ffffff">
	<meta name="color:ALT Accent" content="#8ab4f8">
	
	<!-- Navbar -->
	<meta name="if:Search bar" content="1">
	<meta name="text:Search bar title" content="Search">
	<meta name="if:Direct Message link in navbar" content="1">
	<meta name="if:Random post link" content="1">
	<meta name="if:Archive link" content="1">

	<!-- Sidebar -->
	<meta name="text:Description title" content="Summary">
	<meta name="text:Custom links title" content="Outline">
	<meta name="if:Show group blog members" content="0">
	<meta name="text:Group blog members title" content="Contributors">
	<!-- #endregion -->
	{/block:Hidden}
	
	<!-- Standardization of theme styles -->
	<link rel="stylesheet" href="https://wovenstarlight.github.io/tumblr-themes/normalize.min.css">

	<!-- #region Resource imports -->
	<!-- Google's material icons -->
	<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@48,400,0,0" />
	<!-- #endregion -->

	<style>
	{NewPostStyles}
	html {
		--title-font: {TitleFont};
		--title-font-weight: {TitleFontWeight};
	}

	/* Color options */
	html:not(.alt) {
		--text: {color:Text};
		--text--rgb: {RGBcolor:Text};
		--bg: {color:Page background};
		--bg--rgb: {RGBcolor:Page background};
		--post-bg: {color:Post background};
		--post-bg--rgb: {RGBcolor:Post background};
		--accent: {color:Accent};
		--accent--rgb: {RGBcolor:Accent};
	}
	html.alt {
		--text: {color:ALT Text};
		--text--rgb: {RGBcolor:ALT Text};
		--bg: {color:ALT Page background};
		--bg--rgb: {RGBcolor:ALT Page background};
		--post-bg: {color:ALT Post background};
		--post-bg--rgb: {RGBcolor:ALT Post background};
		--accent: {color:ALT Accent};
		--accent--rgb: {RGBcolor:ALT Accent};
	}
	</style>
	<link rel="stylesheet" href="https://wovenstarlight.github.io/tumblr-themes/docstheme/docstheme.min.css">
	<style>{CustomCSS}</style>
	
	<!-- Keyboard navigation -->
	<script src="https://static.tumblr.com/h7vugp8/mpvrzz0c4/docstheme_keyboardnav.js"></script>
</head>



<body class="{block:IndexPage} index-page{/block:IndexPage}{block:PermalinkPage} permalink{/block:PermalinkPage}{block:AskPage} ask-page{/block:AskPage}{block:SubmitPage} submit-page{/block:SubmitPage}{block:LikesPage} likes-page{/block:LikesPage}{block:FollowingPage} following-page{/block:FollowingPage}{block:SearchPage} search-page{block:NoSearchResults} no-results{/block:NoSearchResults}{block:NoLikes} no-likes{/block:NoLikes}{block:NoPosts} no-posts{/block:NoPosts}{block:NoFollowing} no-following{/block:NoFollowing}{/block:SearchPage} {block:ShowAvatar}hasavatar{/block:ShowAvatar} {block:ShowDescription}{block:Description}hasdesc{/block:Description}{/block:ShowDescription} {block:HasPages}haspages{/block:HasPages} {block:IfShowGroupBlogMembers}{block:GroupMembers}hasmembers{/block:GroupMembers}{/block:IfShowGroupBlogMembers}">

<!-- Accessibility: SKIP TO MAIN -->
<a href="#main" id="skip" class="hidden">Skip to main content</a>


<header id="pagehead">
	<a href="/" id="docs">
		<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 64 88" xml:space="preserve">
			<path d="M58,88H6c-3.3,0-6-2.7-6-6V6c0-3.3,2.7-6,6-6h36l22,22v60C64,85.3,61.3,88,58,88z" fill="#3086F6"/>
			<path d="M42,0l22,22H42V0z" fill="#0C67D6"/>
			<path d="M50,39H14v-5h36V39z M50,46H14v5h36V46z M40,58H14v5h26V58z" fill="#FDFFFF"/>
		</svg>
	</a>
	<a href="/" id="title">
		<h1>
			{block:ShowTitle}{Title}{/block:ShowTitle}
			{block:HideTitle}{Name}{/block:HideTitle}
		</h1>
	</a>
	<h2 id="subtitle">
		{block:HomePage}
			<span>Showing all posts</span>
			{block:Pagination}
				<span class="hidden">-</span>
				<span>{lang:Page CurrentPage of TotalPages}</span>
			{/block:Pagination}
		{/block:HomePage}
		{block:TagPage}
			<span>{lang:Showing TagResultCount posts tagged Tag 2}</span>
			<span class="hidden">-</span>
			<a href="/tagged/{URLSafeTag}">Newest first</a>
			<span class="hidden">-</span>
			<a href="/tagged/{URLSafeTag}/chrono">Oldest first</a>
			{block:Pagination}
				<span class="hidden">-</span>
				<span>{lang:Page CurrentPage of TotalPages}</span>
			{/block:Pagination}
		{/block:TagPage}
		{block:DayPage}
			<span>{lang:Viewing everything posted on Month DayOfMonth Year}</span>
		{/block:DayPage}
		{block:SearchPage}
			<span>
				{lang:Showing SearchResultCount results for SearchQuery 2}
				{block:NoSearchResults}{lang:No results for SearchQuery 2}{/block:NoSearchResults}
			</span>
			{block:Pagination}
				<span class="hidden">-</span>
				<span>{lang:Page CurrentPage of TotalPages}</span>
			{/block:Pagination}
		{/block:SearchPage}
		{block:PermalinkPage}
			{block:PostSummary}<span>{PostSummary}</span>{/block:PostSummary}
		{/block:PermalinkPage}
	</h2>
	
	{block:ShowAvatar}
	<a href="/" id="avatar">
		<img src="{PortraitURL-128}" class="{AvatarShape}" />
	</a>
	{/block:ShowAvatar}

	<nav id="blognav">
		<div class="left">
			{block:IfSearchBar}
			<!-- SEARCH BAR -->
			<form action="/search" method="get" id="search" data-collapsed="true">
				<button id="togglesearch" type="button"><span class="material-symbols-outlined">search</span></button>
				<label for="q" class="hidden">{block:IfSearchBarTitle}{text:Search bar title}{/block:IfSearchBarTitle}{block:IfNotSearchBarTitle}{lang:Search}{/block:IfNotSearchBarTitle}</label>
				<input id="q" type="text" name="q" value="{SearchQuery}" placeholder="{block:IfSearchBarTitle}{text:Search bar title}{/block:IfSearchBarTitle}{block:IfNotSearchBarTitle}{lang:Search}{/block:IfNotSearchBarTitle}"/>
			</form>
			{/block:IfSearchBar}

			<a id="prev" title="{lang:Previous}"
				{block:Pagination}{block:PreviousPage}href="{PreviousPage}"{/block:PreviousPage}{/block:Pagination}
				{block:PermalinkPagination}{block:PreviousPost}href="{PreviousPost}"{/block:PreviousPost}{/block:PermalinkPagination}
				{block:DayPagination}{block:PreviousDayPage}href="{PreviousDayPage}"{/block:PreviousDayPage}{/block:DayPagination}
			>
				<span class="material-symbols-outlined">undo</span>
			</a>
			<a id="next" title="{lang:Next}"
				{block:Pagination}{block:NextPage}href="{NextPage}"{/block:NextPage}{/block:Pagination}
				{block:PermalinkPagination}{block:NextPost}href="{NextPost}"{/block:NextPost}{/block:PermalinkPagination}
				{block:DayPagination}{block:NextDayPage}href="{NextDayPage}"{/block:NextDayPage}{/block:DayPagination}
			>
				<span class="material-symbols-outlined">redo</span>
			</a>

			<hr>

			{block:IfPaletteToggle}
			<button id="palette" title="Toggle palette" type="button"><span class="material-symbols-outlined">palette</span></button>
			{/block:IfPaletteToggle}

			<button id="fontminus" title="Increase font size"><span class="material-symbols-outlined">remove</span></button>
			<input id="fontsize" type="number" value="16" min="10" max="24" />
			<button id="fontplus" title="Decrease font size"><span class="material-symbols-outlined">add</span></button>

			<!-- TODO: Accessibility options. Font? -->

			<hr>

			<a href="/" class="homelink" title="{lang:Home}"><span class="material-symbols-outlined">home</span></a>
			{block:AskEnabled}
				<a href="/ask" class="asklink {block:AskPage}current-page{/block:AskPage}" title="{AskLabel}"><span class="material-symbols-outlined">mail</span></a>
			{/block:AskEnabled}
			{block:SubmissionsEnabled}
				<a href="/submit" class="submitlink {block:SubmitPage}current-page{/block:SubmitPage}" title="{SubmitLabel}"><span class="material-symbols-outlined">inbox</span></a>
			{/block:SubmissionsEnabled}
			{block:IfDirectMessageLinkInNavbar}
				<a href="https://www.tumblr.com/message/{Name}" class="messagelink" title="Message"><span class="material-symbols-outlined">add_comment</span></a>
			{/block:IfDirectMessageLinkInNavbar}
			{block:IfRandomPostLink}
				<a href="/random" class="randomlink" title="{lang:Random}"><span class="material-symbols-outlined">shuffle</span></a>
			{/block:IfRandomPostLink}
			{block:IfArchiveLink}
				<a href="/archive" class="archivelink" title="{lang:Archive}"><span class="material-symbols-outlined">archive</span></a>
			{/block:IfArchiveLink}

			<hr>

			<!-- DO NOT REMOVE CREDIT. LEAVE THIS INTACT. -->
			<a id="credit" href="https://starlightthemes.tumblr.com/docstheme" title="{lang:Install this theme}"><span class="material-symbols-outlined">code</span></a>
			<!-- DO NOT REMOVE CREDIT. LEAVE THIS INTACT. -->
		</div>

		<div class="right">
			<span>
				<span class="material-symbols-outlined">visibility</span>
				Viewing
			</span>

			<hr>

			<!-- BACK TO TOP BUTTON -->
			<button id="scrolltotop" title="{lang:Back to top}" type="button" disabled><span class="material-symbols-outlined">expand_less</span></button>
		</div>
	</nav>
</header>


<aside id="left">
	<!-- Show/hide buttons -->
	<button id="showleft" type="button"><span class="material-symbols-outlined">format_list_bulleted</span></button>
	<button id="hideleft" type="button"><span class="material-symbols-outlined">arrow_back</span></button>

	<div id="leftcontent">
		{block:ShowDescription}{block:Description}
		<!-- BLOG DESCRIPTION -->
		<section id="desc">
			<h2>
				{block:IfDescriptionTitle}{text:Description title}{/block:IfDescriptionTitle}
				{block:IfNotDescriptionTitle}{lang:About}{/block:IfNotDescriptionTitle}
			</h2>
			<div class="content">{Description}</div>
		</section>
		{/block:Description}{/block:ShowDescription}

		{block:HasPages}
		<hr>

		<!-- CUSTOM PAGES -->
		<nav id="pages">
			<h2>
				{block:IfCustomLinksTitle}{text:Custom links title}{/block:IfCustomLinksTitle}
				{block:IfNotCustomLinksTitle}{lang:Navigate}{/block:IfNotCustomLinksTitle}
			</h2>
			{block:Pages}<a href="{URL}" class="{CurrentState}">{Label}</a>{/block:Pages}
		</nav>
		{/block:HasPages}

		{block:IfShowGroupBlogMembers}{block:GroupMembers}
		<hr>

		<!-- BLOG MEMBERS -->
		<section id="members">
			<h2>
				{block:IfGroupBlogMembersTitle}{text:Group blog members title}{/block:IfGroupBlogMembersTitle}
				{block:IfNotGroupBlogMembersTitle}{lang:Group members}{/block:IfNotGroupBlogMembersTitle}
			</h2>
			{block:GroupMember}
			<a href="{GroupMemberURL}">{GroupMemberName}</a>
			{/block:GroupMember}
		</section>
		{/block:GroupMembers}{/block:IfShowGroupBlogMembers}
	</div>
</aside>


<main id="main">

	<section id="posts">
		<noscript><article>Javascript is required to view this blog. Please enable scripting and reload.</article></noscript>
	</section>

<script>
// #region CONSTANTS AND GLOBAL VARIABLES
/**
 * Information of the blog this theme is being used on. For use when this blog makes/adds to posts.
 */
const currentUser = {
	/**
	 * Blog username
	 * @type {string}
	 */
	name: {JSName},
	/**
	 * Blog title
	 * @type {string}
	 */
	title: {JSTitle},
	/**
	 * Blog description. May contain HTML
	 * @type {string}
	 */
	description: {JSDescription},
	/**
	 * URL to the blog (in the format https://username.tumblr.com)
	 * @type {string}
	 */
	url: {JSBlogURL},
	/**
	 * Whether the blog is active. Always true
	 * @type {boolean}
	 */
	active: true,
	/**
	 * Blog theme object. Contains information about colors/blog layout
	 */
	theme: {
		background_color: {JSBackgroundColor},
		title_color: {JSTitleColor},
		link_color: {JSAccentColor},
		title_font: {JSTitleFont},
	},
}

/**
 * Default HTML tags to wrap specific text content block types in.
 * @type {Object.<string, string>}
 */
const textSubtypes = {
	"heading1": "h2",
	"heading2": "h3",
	"quirky": "p",
	"quote": "p",
	"indented": "blockquote",
	"chat": "p",
	"ordered-list-item": "li",
	"unordered-list-item": "li",
}

/**
 * For use in trail item body construction. The base element (paragraph, blockquote etc.) as selected from textSubtypes.
 * @type {HTMLElement}
 */
let bit;
/**
 * For use in trail item body construction. The parent element for list items. Null when no list is being constructed.
 * @type {?string}
 */
let list;

/**
 * For use in audio posts. Stores the request ID for the animation frames.
 * @type {?long}
 */
let rAF = null;
/**
 * For use in audio posts. Stores the currently playing audio element, if any.
 * @type {?HTMLElement}
 */
let currentlyPlaying = null;

/**
 * The currently active lightbox, if any.
 * @type {?HTMLElement}
 */
let lightbox;
/**
 * All images from the trail item currently being represented in the lightbox. Null if no lightbox is active.
 * @type {?HTMLElement[]}
 */
let lightboxImages = null;
/**
 * The index in lightboxImages of the image currently being viewed in the lightbox. Null if no lightbox is active.
 * @type {?number}
 */
let lightboxIndex = null;
/**
 * The image the currently active lightbox was opened from. Null if no lightbox is active.
 * @type {?HTMLElement}
 */
let comingFrom = null;
// #endregion



// #region POST CREATION
// #region Post array declaration
let posts = [
	{block:Posts}
	{
		npf: {NPF},

		{block:PermalinkPage}
		// For ask/submit/general blog pages
		{block:Title} title: {JSTitle}, {/block:Title}
		body: {JSBody},
		{/block:PermalinkPage}

		{block:Date}
		// Post-specific items

		id: {JSPostID},
		permalink: {JSPermalink},
		
		date: {
			day: {JSDayOfWeek},
			textDM: "{DayOfMonth} {Month}, {Year}",
			numDM: "{DayOfMonth}/{MonthNumber}/{Year}",
			textMD: "{Month} {DayOfMonth}, {Year}",
			numMD: "{MonthNumber}/{DayOfMonth}/{Year}",
			textDMZ: "{DayOfMonthWithZero} {Month}, {Year}",
			numDMZ: "{DayOfMonthWithZero}/{MonthNumberWithZero}/{Year}",
			textMDZ: "{Month} {DayOfMonthWithZero}, {Year}",
			numMDZ: "{MonthNumberWithZero}/{DayOfMonthWithZero}/{Year}",
			time12: "{12Hour}:{Minutes} {CapitalAmPm}",
			time24: "{24Hour}:{Minutes}",
			time12Z: "{12HourWithZero}:{Minutes} {CapitalAmPm}",
			time24Z: "{24HourWithZero}:{Minutes}",
			url: "/day/{Year}/{MonthNumberWithZero}/{DayOfMonthWithZero}",
		},

		{block:PinnedPostLabel} pinned: {JSPinnedPostLabel}, {/block:PinnedPostLabel}

		{block:HasTags} tags: [
			{block:Tags} {
				name: "{Tag}",
				url: {JSTagURL},
			}, {/block:Tags}
		], {/block:HasTags}

		{block:RebloggedFrom}
		via: {
			name: {JSReblogParentName},
			url: {JSReblogParentURL},
			label: "{lang:Reblogged from ReblogParentName}",
			labellink: `{lang:Reblogged from ReblogParentName 2}`,
		},
		source: {
			name: {JSReblogRootName},
			url: {JSReblogRootURL},
			label: "{lang:Originally from ReblogRootName}",
			labellink: `{lang:Originally from ReblogRootName 2}`,
		},
		{/block:RebloggedFrom}

		{block:NoteCount}
		noteCount: {JSNoteCountWithLabel},
		postNotes: {JSPostNotesURL},
		{/block:NoteCount}
		
		like_html: {JSLikeButton size="30"},
		reblog_url: {JSReblogURL},

		{block:Submission} submission: {
			name: {JSSubmitter},
			url: {JSSubmitterURL},
			label: "{lang:Submitted By}",
		}, {/block:Submission}

		{block:ContentSource} contentSource: {
			name: {JSSourceTitle},
			url: {JSSourceURL},
			{block:SourceLogo} logo: {
				url: {JSBlackLogoURL},
				width: {JSLogoWidth},
				height: {JSLogoHeight},
			}, {/block:SourceLogo}
		}, {/block:ContentSource}

		{/block:Date}
	},
	{/block:Posts}
	{block:NoPosts}
	{
		npf: {
			content: [
				{
					type: "text",
					text: "{lang:This Tumblr hasnt posted anything}"
				}
			],
			layout: [],
			trail: []
		}
	}
	{/block:NoPosts}
	{block:NoSearchResults}
	{
		npf: {
			content: [
				{
					type: "text",
					text: `{lang:Sorry no results for SearchQuery 2}.`
				}
			],
			layout: [],
			trail: []
		}
	}
	{/block:NoSearchResults}
];
// #endregion

/** The wrapper element in which all posts will be inserted */
let postContainer = document.getElementById("posts");

// #region The main post creation loop
posts.forEach(post => {
	/** The HTML article corresponding to the post currently being created */
	let article = document.createElement("article");
	article.classList.add("post");
	postContainer.append(article);

	// Backup method, using the old "body" T-var
	if ((post.npf.content.length === 0 && post.npf.trail.length === 0) {block:AskPage}|| true{/block:AskPage}{block:SubmitPage}|| true{/block:SubmitPage}) {
		createPage(article, post);
		return;
	}
	// Regardless of NPF/.body creation, mark if currently on a custom blog page
	if (document.querySelector("#pages .current-page") != null)
		document.body.classList.add("page");

	// Content available via NPF
	// Create, but put guards in for header/footer just in case pages are parsed as NPF too
	
	if (post.id !== undefined)
		createPostHeader(article, post);

	/** The body of the post, to be populated with trail items */
	let postBody = document.createElement("section");
	postBody.classList.add("body");
	article.append(postBody);
	// Create each reblog of the post
	if (!post.npf.trail.length) { article.classList.add("original") }
	else { post.npf.trail.forEach(trailItem => createTrailItem(postBody, trailItem, null)) }
	// End with the current blog's addition, if any, and expand if on the permalink page
	if (post.npf.content.length) {
		createTrailItem(
			postBody,
			post.npf,
			post.id
			{block:PermalinkPage}, true{/block:PermalinkPage}
		);
	}

	if (post.id !== undefined)
		createPostFooter(article, post);
});
// #endregion

// #region Remaining post functionality
// Add lightboxes to all applicable images
document.querySelectorAll("img.lightboxable").forEach(obj => {
	obj.setAttribute("tabindex", "0");
	obj.addEventListener("click", triggerLightbox);
	obj.addEventListener("keydown", e => {
		if (e.key === "Enter" || e.key === " ") { triggerLightbox(e) }
	});
});

// Add post notes on permalink pages
if (document.body.classList.contains("permalink") && posts.at(0)?.postNotes) {
	document.body.setAttribute("data-sidebar-collapsed", true);
	document.body.classList.add("hasnotes")
	createNotes(posts[0].postNotes);
}
// #endregion

// #region Remaining page functionality (base features)
// Search bar show/hide
document.getElementById("togglesearch")?.addEventListener("click", () => {
	document.getElementById("search").toggleAttribute("data-collapsed");
})
{block:SearchPage}
document.getElementById("search")?.removeAttribute("data-collapsed");
{/block:SearchPage}

// Sidebar show/hide
document.getElementById("showleft").addEventListener("click", () => {
	document.body.removeAttribute("data-sidebar-collapsed");
})
document.getElementById("hideleft").addEventListener("click", () => {
	document.body.setAttribute("data-sidebar-collapsed", true);
})
// #endregion

// #region Remaining page functionality (accessibility features)
// Set up keyboard navigation
keyboardNav();

// Palette
document.getElementById("palette").addEventListener("click", () => {
	let added = document.body.parentElement.classList.toggle("alt");

	// Persistence
	localStorage.setItem("palette", added ? "alt" : "");
});
// Persistence
if ((palette = localStorage.getItem("palette")) !== null)
	palette === "alt" ? document.body.parentElement.classList.add("alt") : document.body.parentElement.classList.remove("alt");

// Font sizing
let fontsize = document.getElementById("fontsize"),
	fontplus = document.getElementById("fontplus"),
	fontminus = document.getElementById("fontminus");
fontsize.addEventListener("change", e => {
	let input = e.target,
		val = Math.round(parseFloat(input.value));
	
	// Valid and non-empty
	if (input.checkValidity() && input.value !== "")
		fontSizeSetter(parseInt(input.value));
	
	// Otherwise, some variant of invalid, whether that be:
	// Empty string or non-numerical
	else if (input.checkValidity() || isNaN(val))
		fontSizeSetter(parseInt(input.getAttribute("data-current")) ?? 16);
	
	// OR either a float, <min, or >max
	else {
		let val2 = Math.max(
			parseInt(input.getAttribute("min")),
			Math.min(
				parseInt(input.getAttribute("max")),
				val
			)
		);
		fontSizeSetter(parseInt(val2));
	}
});
fontplus.addEventListener("click", e => {
	var val = isNaN(parseInt(fontsize.value))
		? fontsize.getAttribute("data-current") ?? 16
		: Math.min(parseInt(fontsize.value) + 1, parseInt(fontsize.getAttribute("max")));
	fontSizeSetter(parseInt(val));
});
fontminus.addEventListener("click", e => {
	var val = isNaN(parseInt(fontsize.value))
		? fontsize.getAttribute("data-current") ?? 16
		: Math.max(parseInt(fontsize.value) - 1, parseInt(fontsize.getAttribute("min")));
	fontSizeSetter(parseInt(val));
});
/**
 * Helper for font size event listeners. Updates font size and toggles sizing buttons as necessary.
 * @param {number} sizeValue The integer value for the new font size.
 */
function fontSizeSetter(sizeValue) {
	fontsize.value = sizeValue;
	fontsize.setAttribute("data-current", sizeValue);
	postContainer.setAttribute("style", "--fontsize: "+sizeValue+"px;");

	// Disable/enable font size buttons as necessary
	if (sizeValue === parseInt(fontsize.getAttribute("max"))) { fontplus.setAttribute("disabled", "disabled") }
	else { fontplus.removeAttribute("disabled") }
	if (sizeValue === parseInt(fontsize.getAttribute("min"))) { fontminus.setAttribute("disabled", "disabled") }
	else { fontminus.removeAttribute("disabled") }

	// Persistence
	localStorage.setItem("fontsize", sizeValue);
};
// Persistence
if ((size = localStorage.getItem("fontsize")) !== null)
	fontSizeSetter(parseInt(size));

// TODO: Font?

// Scroll to top
(scrolltotop = document.getElementById("scrolltotop")).addEventListener("click", () => {
	window.scrollTo({
		top: 0,
		behavior: "smooth",
	});
});
document.addEventListener("scroll", () => {
	if (window.pageYOffset <= 100) {
		scrolltotop.setAttribute("disabled", "true");
	}
	else {
		scrolltotop.removeAttribute("disabled");
	}
})
// #endregion

// #region Visual extras for page
// Format media in posts in legacy style
formatLegacyStyle();

// Fill in #subtitle if empty
if ((subtitle = document.getElementById("subtitle")).textContent.length === 0) {
	// Only blank on permalink pages with no text content of any sort => always a media post,
	// OR on custom pages with no title defined => might have text, need to check.
	// (Ask and submit pages will always have default text, even when the user blanks out the label)

	let label = document.createElement("span");

	if (document.body.classList.contains("page")) {
		let text = document.querySelector(".post .bodyitemcontent").textContent,
			text2 = text.length > 50 ? text.slice(0, 50).concat("…") : text,
			first = posts[0].npf?.content.find(e => e.type==="text")?.text;
		label.innerText = text2.length < first.length ? text2 : first;
	}
	else {
		label.innerText = "Media post";
	}
	document.title += ` — ${label.innerText}`;
	subtitle.append(label);
}
// #endregion
// #endregion



// #region CONSTRUCTOR FUNCTIONS

// #region FOR POST HEADER/FOOTER
/**
 * Creates a post header object and appends it to the given post object.
 * The individual elements in the header can be rearranged as per theme preference.
 * @param {HTMLElement} wrapper The HTML object for this post, to which the header will be added.
 * @param {Object} postData This post's data, containing relevant information to populate the header with.
 */
function createPostHeader(wrapper, postData) {
	let header = document.createElement("header");
	wrapper.append(header);

	// Populate post header
	makeDate(header, postData);

	makePin(header, postData);

	makeContentSource(header, postData);

	makeSubmitter(header, postData);
}

/**
 * Creates a post footer object and appends it to the given post object.
 * The individual elements in the footer can be rearranged as per theme preference.
 * @param {HTMLElement} wrapper The HTML object for this post, to which the footer will be added.
 * @param {Object} postData This post's data, containing relevant information to populate the footer with.
 */
function createPostFooter(wrapper, postData) {
	let footer = document.createElement("footer");
	wrapper.append(footer);
	
	// Populate post footer
	let vsn = document.createElement("span");
	vsn.classList.add("vsn");
	footer.append(vsn);
	makeNoteCount(vsn, postData);
	makeViaSource(vsn, postData);

	let lr = document.createElement("span");
	lr.classList.add("lr");
	footer.append(lr);
	makeLike(lr, postData);
	makeReblog(lr, postData);

	makeTags(footer, postData);
}

// #region Helpers
/**
 * Creates a like button for a given post.
 * @param {HTMLElement} wrapper The child element of the post to which the like button will be added. Usually the footer.
 * @param {Object} postData This post's data, containing relevant information to create the like button with.
 * @param {?string} icon An HTML string representing the icon for the like button, or null if a text label should be used.
 */
function makeLike(wrapper, postData, icon = null) {
	// Make element
	let likeButton = document.createElement("a");
	likeButton.href = "#";
	likeButton.classList.add("customlike");
	likeButton.innerHTML = postData.like_html;
	wrapper.append(likeButton);
	
	// Icon or text, as needed
	let label = `<span class="to-like">{block:English}Like{/block:English}{block:German}Liken{/block:German}{block:French}J'aime{/block:French}{block:Italian}Mi piace{/block:Italian}{block:Japanese}スキ{/block:Japanese}{block:Turkish}Beğen{/block:Turkish}{block:Spanish}Me gusta{/block:Spanish}{block:Russian}Нравится{/block:Russian}{block:Polish}Lubię{/block:Polish}{block:PortuguesePT}Gostar{/block:PortuguesePT}{block:PortugueseBR}Curtir{/block:PortugueseBR}{block:Dutch}Vind ik leuk{/block:Dutch}{block:Korean}좋아요{/block:Korean}{block:ChineseSimplified}喜欢{/block:ChineseSimplified}{block:ChineseTraditional}喜歡{/block:ChineseTraditional}{block:ChineseHK}喜歡{/block:ChineseHK}{block:Indonesian}Suka{/block:Indonesian}{block:Hindi}पसंद करें{/block:Hindi}</span>`;
	if (icon !== null) {
		// Assumes icon is an HTML string
		likeButton.innerHTML += icon;
		likeButton.title = label;
	}
	else {
		// No icon provided; use text labels
		// Like text
		likeButton.innerHTML += label;
		// Unlike text
		likeButton.innerHTML += `<span class="to-unlike">{block:English}Unlike{/block:English}{block:German}Entliken{/block:German}{block:French}Je n'aime plus{/block:French}{block:Italian}Non mi piace{/block:Italian}{block:Japanese}スキ解除{/block:Japanese}{block:Turkish}Beğenme{/block:Turkish}{block:Spanish}Ya no me gusta{/block:Spanish}{block:Russian}Не нравится{/block:Russian}{block:Polish}Nie lubię{/block:Polish}{block:PortuguesePT}Deixar de gostar{/block:PortuguesePT}{block:PortugueseBR}Curtir (desfazer){/block:PortugueseBR}{block:Dutch}Vind ik niet meer leuk{/block:Dutch}{block:Korean}좋아요 취소{/block:Korean}{block:ChineseSimplified}取消喜欢{/block:ChineseSimplified}{block:ChineseTraditional}收回喜歡{/block:ChineseTraditional}{block:ChineseHK}收回喜歡{/block:ChineseHK}{block:Indonesian}Tidak Suka{/block:Indonesian}{block:Hindi}पसंद हटाएँ{/block:Hindi}</span>`;
	}
}

/**
 * Creates a reblog button for a given post.
 * @param {HTMLElement} wrapper The child element of the post to which the reblog button will be added. Usually the footer.
 * @param {Object} postData This post's data, containing relevant information to create the reblog button with.
 * @param {?string} icon An HTML string representing the icon for the reblog button, or null if a text label should be used.
 */
function makeReblog(wrapper, postData, icon = null) {
	// Make element
	let reblogButton = document.createElement("a");
	reblogButton.href = postData.reblog_url;
	reblogButton.classList.add("customreblog");
	wrapper.append(reblogButton);

	// Icon or text, as needed
	let label = "{block:English}Reblog{/block:English}{block:German}Rebloggen{/block:German}{block:French}Rebloguer{/block:French}{block:Italian}Reblogga{/block:Italian}{block:Japanese}リブログ{/block:Japanese}{block:Turkish}Yeniden Blogla{/block:Turkish}{block:Spanish}Rebloguear{/block:Spanish}{block:Russian}Реблог{/block:Russian}{block:Polish}Rebloguj{/block:Polish}{block:PortuguesePT}Reblogar{/block:PortuguesePT}{block:PortugueseBR}Reblogar{/block:PortugueseBR}{block:Dutch}Rebloggen{/block:Dutch}{block:Korean}리블로그{/block:Korean}{block:ChineseSimplified}转发{/block:ChineseSimplified}{block:ChineseTraditional}轉格{/block:ChineseTraditional}{block:ChineseHK}轉載{/block:ChineseHK}{block:Indonesian}Reblog{/block:Indonesian}{block:Hindi}रीब्लॉग करें{/block:Hindi}";
	if (icon !== null) {
		reblogButton.innerHTML = icon;
		reblogButton.title = label;
	}
	else {
		reblogButton.innerText = label;
	}
}

/**
 * Creates a label indicating that a given post is a pinned post.
 * @param {HTMLElement} wrapper The child element of the post to which the pinned marker will be added. Usually the header.
 * @param {Object} postData This post's data, containing relevant information to create the pinned marker with.
 * @param {?string} icon An HTML string representing the icon for the pinned marker, or null if a text label should be used.
 */
function makePin(wrapper, postData, icon = null) {
	if (!postData.pinned) { return; }
	// Make element
	let pin = document.createElement("span");
	pin.id = "pinnedpost";
	wrapper.append(pin);
	// Icon or text, as needed
	if (icon !== null) {
		pin.innerHTML = icon;
		pin.title = postData.pinned;
	}
	else {
		pin.innerText = postData.pinned;
	}
}

/**
 * Creates links to the blogs that a given post was reblogged from (via) and originally made by (source).
 * @param {HTMLElement} wrapper The child element of the post to which the via/source links will be added. Usually the footer.
 * @param {Object} postData This post's data, containing relevant information to create the via/source links with.
 */
function makeViaSource(wrapper, postData) {
	if (!postData.via) { return; }
	// Via and source links
	let via = document.createElement("a"),
		source = document.createElement("a");

	// Via URL always exists; add
	via.href = postData.via.url;
	wrapper.append(via);

	// Check if source blog/post still exists
	let sourceTrail = postData.npf.trail[0];
	if (sourceTrail?.blog) {
		source.href = sourceTrail.blog.url.concat(sourceTrail.blog.url.endsWith("/") ? `post/${sourceTrail.post.id}` : `/${sourceTrail.post.id}`);
		wrapper.append(source);
	}
	else if (postData.source.url !== "") {
		source.href = postData.source.url;
		wrapper.append(source);
	}

	// Add labels
	via.innerText = "{lang:Via}";
	source.innerText = "{lang:Source}";
}

/**
 * Creates a label for the number of notes on a given post.
 * @param {HTMLElement} wrapper The child element of the post to which the note count will be added. Usually the footer.
 * @param {Object} postData This post's data, containing relevant information to create the note count with.
 */
function makeNoteCount(wrapper, postData) {
	if (!postData.noteCount) { return; }
	let notes = document.createElement("a");
	notes.href = postData.permalink.concat("#notes");
	notes.classList.add("notecount");
	notes.innerText = postData.noteCount;
	wrapper.append(notes);
}

/**
 * Creates links to the tags a given post was tagged with.
 * @param {HTMLElement} wrapper The child element of the post to which the tags will be added. Usually the footer.
 * @param {Object} postData This post's data, containing relevant information to create the tag links with.
 * @param {Object} [tagOptions={}] Options for how to display the tags.
 * @param {boolean} [tagOptions.span=false] True if the tags should be contained in a <span> element. False if the container should be a <p> element.
 * @param {boolean} [tagOptions.commas=false] True if the tags should be separated by commas, false otherwise.
 * @param {boolean} [tagOptions.hashtags=true] True if the tags should be prefixed by hashtags, false otherwise.
 */
function makeTags(wrapper, postData, tagOptions = {}) {
	if (!postData.tags) { return; }
	let options = Object.assign({
		span: false,
		commas: false,
		hashtags: true,
	}, tagOptions);
	// Make element
	let tags = document.createElement(options.span ? "span" : "p");
	tags.classList.add("tags");
	// Populate with each tag
	let tagList = postData.tags.map(tag => `<a href="${tag.url}">`.concat(options.hashtags ? "#" : "",`${tag.name}</a>`));
	tags.innerHTML = tagList.join(options.commas ? ", " : "");
	wrapper.append(tags);
}

/**
 * Creates a date label showing when a given post was posted/reblogged.
 * @param {HTMLElement} wrapper The child element of the post to which the date label will be added. Usually the header.
 * @param {Object} postData This post's data, containing relevant information to create the date label with.
 * @param {Object} [dateOptions={}] Options for the formatting of the date.
 * @param {boolean} [dateOptions.includeDay=false] True if the weekday should be included in the date label, false otherwise.
 * @param {string} [dateOptions.dateFormat="textDM"] The format of the date, month, and year portion of the label. Either "text" or "num" (numerical) for the month name, "DM" or "MD" for the date-month ordering, followed by an optional "Z" if dates and months should be zero-padded.
 * @param {boolean} [dateOptions.includeTime=false] True if the time of reblogging/posting should be included in the date label, false otherwise.
 * @param {string} [dateOptions.timeFormat="12"] The format of the time portion of the label. Either "12" or "24" for 12-hour (AM/PM) or 24-hour format, followed by an optional "Z" if hours should be zero-padded.
 * @param {boolean} [dateOptions.commaSeparate=true] For when includeTime is set to true. True if the label should be formatted as "[DATE], [TIME]", and false if the label should be formatted as "[DATE] at [TIME]".
 */
function makeDate(wrapper, postData, dateOptions = {}) {
	let options = Object.assign({
		includeDay: false,
		dateFormat: "textDM",
		includeTime: false,
		timeFormat: "12",
		commaSeparate: true,
	}, dateOptions),
		date = document.createElement("a");
	// Make element
	date.href = postData.permalink;
	date.classList.add("date");
	wrapper.append(date);
	// Add day, as needed
	if (options.includeDay) {
		date.innerText = postData.date.day.concat(", ");
	};
	// Add date
	date.innerText += postData.date[options.dateFormat];
	// Add time, as needed
	if (options.includeTime) {
		date.innerText += commaSeparate ? ", " : " at ";
		date.innerText += postData.date[`time${options.timeFormat}`];
	}
}

/**
 * Creates a label indicating a given post is a submission.
 * @param {HTMLElement} wrapper The child element of the post to which the submission label will be added. Usually the header.
 * @param {Object} postData This post's data, containing relevant information to create the submission label with.
 * @param {boolean} [label=true] True if a text label should be included giving the submitter's name, potentially with a link to their blog
 */
function makeSubmitter(wrapper, postData, label = true) {
	if (!(subData = postData.submission)) { return; }
	let sublabel = document.createElement("span");
	sublabel.classList.add("sublabel");
	wrapper.append(sublabel);
	// Submitter name, with link to blog if provided
	// (only if labels are requested!)
	if (label) {
		if (subData.url.length) {
			sublabel.innerHTML = subData.label.replace(subData.name, `<a href="${subData.url}">${subData.name}</a>`);
		}
		else {
			sublabel.innerHTML = subData.label.replace(subData.name, `<a>${subData.name}</a>`);
		}
	}
	else {
		sublabel.title = subData.label;
	}
}

/**
 * Creates a label indicating the source of a given post's content.
 * @param {HTMLElement} wrapper The child element of the post to which the content source label will be added. Usually the header.
 * @param {Object} postData This post's data, containing relevant information to create the content source with.
 * @param {boolean} [label=true] True if a "Source:" prefix should be included before the link to the source, false otherwise
 * @param {boolean} [logo=false] True if any provided logos should be displayed on the link instead of the source's text name, false otherwise
 */
function makeContentSource(wrapper, postData, label = true, logo = false) {
	if (!(sourceData = postData.contentSource)) { return; }
	let source = document.createElement("span");
	source.classList.add("source");
	wrapper.append(source);
	// Include label?
	if (label) { source.innerText = "{lang:Source}: " }
	// Display as...
	if (logo && sourceData.logo) {
		// Image, no text
		source.innerHTML += `<a href="${sourceData.url}"><img src="${sourceData.logo.url}" width="${sourceData.logo.width}" height="${sourceData.logo.height}" alt="${sourceData.name}" /></a>`;
	}
	else {
		// Text, no image
		source.innerHTML += `<a href="${sourceData.url}">${sourceData.name}</a>`;
	}
}
// #endregion
// #endregion

// #region FOR POST BODY
/** Creates a trail item in the body of a post, containing a single blog's contribution to that post.
 * @param {HTMLElement} post The wrapper into which to insert the complete trail item, usually a post body element.
 * @param {Object} npf The NPF object containing information about this trail item.
 * @param {string} postID The ID of this specific iteration of the post, as seen in the URL.
 * @param {boolean} [expand=false] True if any "read more" dividers in a post should be skipped and the full post rendered; false if the "read more" should be rendered and subsequent content hidden.
 */
function createTrailItem(post, npf, postID, expand = false) {
	let item = document.createElement("div");
	item.classList.add("bodyitem");
	post.append(item);
	
	// extant blog; create directly
	if (npf.blog !== undefined) { createTrailItemHeader(item, npf.blog, npf.post) }
	
	// deleted/unrecoverable blog
	else if (npf.broken_blog_name !== undefined) {
		createTrailItemHeader(item, { name: npf.broken_blog_name });
	}
	
	// blog is currentUser; provide directly-pulled info
	else { createTrailItemHeader(item, currentUser, { id: postID }) }
	
	// create the body of their contribution
	createTrailItemBody(item, npf, { id: postID }, expand);
}


/**
 * Creates the header for a specific trail item, rendering the blog that authored this trail item (and any badges/accessories they use). Includes links to the versions of the post on the contributing blogs, where available.
 * @param {HTMLElement} trailItem The trail item wrapper into which to insert the header.
 * @param {Object} blogData Information about the user that authored this trail item.
 * @param {Object} [postData=null] Information about this iteration of the post; null if the blog that authored this iteration is deactivated/broken or if the post is otherwise unavailable.
 */
function createTrailItemHeader(trailItem, blogData, postData = null) {
	let header = document.createElement("header");
	header.classList.add("user");
	trailItem.append(header);
	let link = document.createElement("a");
	header.append(link);
	
	// mark broken trail items
	if (postData === null || blogData.active === false) { header.classList.add("deactivated") }
	
	// add link where original posts exist, with safeguards for pages
	if (postData?.id === undefined && blogData.active != null) {
		// page! link back to itself
		link.href = window.location.href;
	}
	else if (blogData.url && blogData.active) {
		link.href = blogData.url.concat(blogData.url.endsWith("/") ? `post/${postData.id}` : `/${postData.id}`);
	}
	
	// Get the username
	let username = document.createElement("span");
	username.classList.add("name");
	username.innerHTML = blogData.name;
	// put together the header
	link.append(username);
	link.setAttribute("style", `--bg: ${blogData?.theme?.background_color ?? currentUser.theme.background_color}; --text: ${blogData?.theme?.title_color ?? currentUser.theme.title_color}; --accent: ${blogData?.theme?.link_color ?? currentUser.theme.link_color}`)
}


/**
 * Renders the body of each individual trail item.
 * @param {HTMLElement} trailItem The trail item wrapper into which to insert the body.
 * @param {Object} npf The NPF object containing information about this trail item.
 * @param {string} postID The ID of this specific iteration of the post, as seen in the URL.
 * @param {boolean} expand True if any "read more" dividers in a post should be skipped and the full post rendered; false if the "read more" should be rendered and subsequent content hidden.
 */
function createTrailItemBody(trailItem, npf, postData, expand) {
	let content = npf.content;
	let rows = npf.layout.find(l => l.type === "rows");
	let body = document.createElement("div");
	body.classList.add("bodyitemcontent");
	trailItem.append(body);

	for (let i = 0; i < content.length; i ++) {
		// figure out the content type and create the block based on that
		createContentBlock(
			body, content, i,
			// For poll content blocks, a link to the in-dashboard view
			npf.blog !== undefined ? npf.blog.blog_view_url.concat("/", npf.post.id)
				: npf.broken_blog_name === undefined ? `https://tumblr.com/${currentUser.name}/${postData.id}`
				: "",
			// For paywall content blocks, the paywaller's info and the post object for the viewer's subscription status
			npf.blog || currentUser,
			npf.post);
		
		// cut off the post and add a readmore, if one is present and you aren't currently on the post's permalink page
		if (i === rows?.truncate_after && !expand) {
			let readmore = document.createElement("a");
			readmore.classList.add("filechip", "readmore");
			readmore.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" preserveAspectRatio="none" x="0" y="0" viewBox="2 2 15 15"><path xmlns="http://www.w3.org/2000/svg" fill="currentColor" d="M14.5 2h-11C2.67 2 2 2.67 2 3.5v11c0 .83.67 1.5 1.5 1.5h11c.83 0 1.5-.67 1.5-1.5v-11c0-.83-.67-1.5-1.5-1.5zM11 13H5v-1.5h6V13zm2-3.25H5v-1.5h8v1.5zm0-3.25H5V5h8v1.5z"/></svg>`;
			readmore.append("{lang:Read more}");
			body.append(readmore);
			
			let link;
			if (npf.blog !== undefined) { // blog is extant
				link = npf.blog.url.concat(npf.blog.url.endsWith("/") ? `post/${npf.post.id}` : `/${npf.post.id}`);
			} else if (npf.broken_blog_name !== undefined) { // blog is unreachable; no link
				link = null;
			} else { // blog is current user's
				link = currentUser.url.concat(currentUser.url.endsWith("/") ? `post/${postData.id}` : `/${postData.id}`);
			}
			// add link if reachable
			if (link !== null) { readmore.href = link }
			break; // don't render any more post blocks
		}
		else if (i === rows?.truncate_after) {
			let readmore = document.createElement("hr");
			readmore.classList.add("readmore");
			body.append(readmore);
		}
	}
	
	// All base content blocks are done. Adjust layout
	// Put columns into rows
	if (rows) {
		let offset = 0;
		rows.display.filter(i => (i.blocks.length > 1)).forEach((iRow, index) => {
			// Need to move further columns out of their rows into the first column
			// the -offset is because of however many items being put inside rows and therefore being removed from the indices
			
			// Narrow images might not be in NPF rows, so wrap the first element in a row+col if it's not
			var row = body.children[iRow.blocks[0] - offset];
			if (!row.classList.contains("row")) {
				// Make sure to make it lightbox-capable
				row.children[0].classList.add("lightboxable");
				let newRow = document.createElement("div");
				newRow.classList.add("row");
				// Insert in place of element
				row.parentElement.insertBefore(newRow, row);
				newRow.append(row);
				row = newRow;
			}
			
			// and now, move the corresponding columns inside the row
			// skipping the first element, which is already in the row
			for (let i = 1; i < iRow.blocks.length; i ++) {
				if (row.nextElementSibling.classList.contains("row")) {
					// Move next column into row
					row.append(row.nextElementSibling.children[0]);
					// Delete now-empty next row
					row.nextElementSibling.remove();
				}
				else {
					// Image-figure, not row
					// Make sure to make it lightbox-capable
					row.nextElementSibling.children[0].classList.add("lightboxable");
					// Move into row
					row.append(row.nextElementSibling);
				}
			}
			offset += iRow.blocks.length - 1;
		})
	}
	
	// If there's an ask, separate it from its answer, if any
	let askNPF = npf.layout.find(l => l.type === "ask");
	if (askNPF) {
		// Anon or not?
		let asker = document.createElement("header");
		asker.classList.add("user");
		let askerName = document.createElement("a"),
			askingLabel = document.createElement("span");
		if (askNPF.attribution) {
			askerName.href = askNPF.attribution.blog.url;
			askerName.append(askNPF.attribution.blog.name);
			askerName.classList.add("name");
			asker.setAttribute("style", `--bg: ${askNPF.attribution.blog.theme?.background_color ?? currentUser.theme.background_color}; --text: ${askNPF.attribution.blog.theme?.title_color ?? currentUser.theme.title_color}; --accent: ${askNPF.attribution.blog.theme?.link_color ?? currentUser.theme.link_color}`)
		}
		else {
			askerName.append("Anonymous");
			asker.setAttribute("style", `--bg: ${currentUser.theme.background_color}; --text: ${currentUser.theme.title_color}; --accent: ${currentUser.theme.link_color}`)
		}
		askingLabel.innerText = " asked:";
		asker.append(askerName, askingLabel);
		
		let ask = document.createElement("div");
		ask.classList.add("ask");
		ask.append(asker);
		let askBody = document.createElement("div");
		askBody.classList.add("bodyitemcontent");
		ask.append(askBody);
		
		if (rows) {
			// Blocks may already be nested in rows; count off how many should be in the ask
			let i = askNPF.blocks.length;
			while (i > 0) {
				i -= Math.max(1, body.children[0].childElementCount);
				askBody.append(body.children[0]);
			}
		}
		else {
			// just a simple stack. take however many off the top and put them in the ask
			askNPF.blocks.forEach(b => askBody.append(body.children[0]));
		}
		
		// PLACEMENT OPTIONS (note, none of these are inside .bodyitemcontent!):
		// Case 1. In root post body, above answer trail item
		trailItem.parentElement.insertBefore(ask, trailItem);
		// Case 2. Inside same trail item, above answerer's name
		// trailItem.insertBefore(ask, body.previousElementSibling);
		// Case 3. Inside same trail item, below answerer's name
		// trailItem.insertBefore(ask, body);
		
		// Sometimes asks have no answer content (i.e. nothing left in body); in this case, clean up answerer section
		if (body.childElementCount === 0) {
			// Case 1
			trailItem.remove();
			// Case 2
			// body.previousElementSibling.remove(); // the answerer's name
			// Case 2 or 3
			// body.remove(); // the empty answer content
		}
	}
}


/**
 * Renders a single content block in the body of a trail item.
 * @param {HTMLElement} trailItem The trail item body wrapper into which to insert this content block.
 * @param {Object} content The NPF content for the entire trail item, to assist in rendering certain content block types in relation to others in the trail item.
 * @param {number} i The index of this content block in the "content" object, i.e. this block's position in relation to other blocks.
 * @param {string} [blogViewLink=""] The URL to this post in the in-dashboard view, i.e. a link formatted in the style "https://tumblr.com/username/1234567890".
 */
function createContentBlock(trailItem, content, i, blogViewLink = "", blogObj = {}, postObj = {}) {
	let curr = content[i];
	switch (curr.type) {
		
		case "text":
			bit = document.createElement(textSubtypes[curr.subtype] || "p");
			
			bit.innerHTML = formatText(curr);
			
			if (curr.subtype?.includes("ordered-list-item")) {
				// if first bullet point of a type, start a new list
				if (content[i - 1]?.subtype !== curr.subtype) {
					if (list) { trailItem.append(list); }
					list = document.createElement(curr.subtype === "ordered-list-item" ? "ol" : "ul")
				}
				
				list.append(bit); // continue the list
				
				// if last item in the list, or a last list, end the list and add the whole thing
				if (content[i + 1]?.subtype !== curr.subtype || i + 1 === content.length) {
					trailItem.append(list);
					list = null;
				}
			}
			else if ( ["quirky", "quote", "indented", "chat"].includes(curr.subtype) ) {
				bit.classList.add("npf_".concat(curr.subtype));
				trailItem.append(bit);
			}
			// otherwise it's a simple paragraph or blockquote or whatever. add
			else { trailItem.append(bit) }
			
			break;
		
		case "image":
			let breakpoint = 300;
			// wrappers
			// for some reason this breaks if col/row are also in the >=540 block
			let row = document.createElement("div");
			row.classList.add("row");
			let fig = document.createElement("figure");
			if (curr.media[0].width >= breakpoint) {
				fig.classList.add("tmblr-full");
			}
			
			// actual image
			bit = document.createElement("img");
			bit.src = curr.media[0].url;
			bit.width = curr.media[0].width;
			bit.height = curr.media[0].height;
			// add alt text, if present
			if (curr.alt_text) { bit.setAttribute("alt", curr.alt_text) }
			// include colors, if present
			for (color in curr.colors) {
				bit.setAttribute("data-".concat(color), "#".concat(curr.colors[color]));
			}
			// nest the structure and append it to the post
			fig.append(bit);
			if (curr.media[0].width >= breakpoint) {
				// Make large images lightbox-capable
				bit.classList.add("lightboxable");
				
				row.append(fig);
				trailItem.append(row);
			}
			else {
				trailItem.append(fig);
			}
			
			if (curr.caption) { // add caption, if present
				let caption = document.createElement("p");
				caption.innerText = curr.caption;
				fig.insertBefore(caption, bit.nextElementSibling);
			}
			
			if (curr.attribution) {
				let attrib = document.createElement("p");
				attrib.classList.add("tmblr-attribution");
				switch (curr.attribution.type) {
					case "post":
						attrib.innerHTML = `<a href="${curr.attribution.url}">{lang:Via} ${curr.attribution.blog.name}</a>`;
						break;
					case "link":
						attrib.innerHTML = `<a href="${curr.attribution.url}">{lang:Source}</a>`;
						break;
				}
				fig.insertBefore(attrib, bit.nextElementSibling);
			}
			break;
		
		case "link":
			bit = document.createElement("div");
			bit.classList.add("npf-link-block");
			let link = document.createElement("a");
			let poster;
			if (curr.poster) {
				bit.classList.add("has-poster");
				poster = document.createElement("div");
				poster.classList.add("poster");
				poster.style.backgroundImage = `url(${curr.poster[0].url})`;
				link.append(poster);
			} else {
				bit.classList.add("no-poster");
			}
			if (curr.title) {
				let title = document.createElement("div");
				title.classList.add("title");
				title.innerText = curr.title;
				if (curr.poster) { poster.append(title) }
				else { link.append(title) }
			}
			let bottom = document.createElement("div");
			bottom.classList.add("bottom");
			if (curr.description) {
				let desc = document.createElement("div");
				desc.classList.add("description");
				desc.innerText = curr.description;
				bottom.append(desc);
			}
			// get "site name" - just the base url without the https
			let sitename = document.createElement("div");
			sitename.classList.add("site-name");
			// use display url if sitename is absent, as in older links
			sitename.innerText = curr.site_name ? curr.site_name : curr.display_url;
			bottom.append(sitename);
			
			link.append(bottom);
			link.href = curr.url;
			bit.append(link);
			trailItem.append(bit);
			break;
		
		case "audio":
			// Soundcloud links keep throwing 401 errors for some reason, so exclude
			if (curr.media && curr.provider !== "soundcloud") {
				bit = createCustomAudio(curr);
			}
			// TODO: else if client side SDK... need examples of metadata object
			// If embeds are present, use those
			else if (curr.embed_html) {
				bit = document.createElement("div");
				bit.innerHTML = curr.embed_html.trim();
				bit = bit.firstChild;
			}
			else if (curr.embed_url) {
				bit = document.createElement("iframe");
				bit.title = `Audio: ${curr.title || "Unknown title"} — ${curr.artist || "Unknown artist"}`;
				if (curr.album) { bit.title += ` (<em>${curr.album}</em>)` }
				bit.src = curr.embed_url;
				bit.width = "100%";
			}
			else {
				// All else failed; display a plain link to given URL
				bit = document.createElement("a");
				bit.href = curr.url;
				bit.innerText = `${curr.title || "Unknown title"} — ${curr.artist || "Unknown artist"}`;
				if (curr.album) { bit.innerHTML += `, <em>${curr.album}</em>` }
			}
			trailItem.append(bit);
			break;
		
		case "video":
			// Use media object to display default video player
			if (curr.media) {
				bit = document.createElement("video");
				bit.classList.add("video");
				bit.preload = "metadata";
				bit.controls = true;
				if (curr.poster) { bit.poster = curr.poster[0].url }
				bit.src = curr.media.url;
			}
			// TODO: else if client side SDK... need examples of metadata object
			// If embeds are present, use those
			else if (curr.embed_html) {
				bit = document.createElement("div");
				bit.innerHTML = curr.embed_html.trim();
				bit = bit.firstChild;
			}
			else if (curr.embed_url) {
				bit = document.createElement("iframe");
				bit.src = curr.embed_url;
				bit.width = "100%";
			}
			// All else failed; display a plain link to given URL
			else {
				bit = document.createElement("a");
				bit.href = curr.url;
				bit.innerText = curr.url;
			}
			trailItem.append(bit);
			break;

		case "paywall":
			bit = document.createElement("div");
			let title, label;
			bit.classList.add("paywall");
			bit.style.setProperty("--bg", blogObj.theme.background_color);
			bit.style.setProperty("--text", blogObj.theme.title_color);
			bit.style.setProperty("--accent", blogObj.theme.link_color);
			bit.style.setProperty("--font", blogObj.theme.title_font);
			
			if (postObj.paywall_access === "member") {
				// Shouldn't see this block at all! No need to render anything inside
				bit.style.setProperty("display", "none");
				trailItem.append(bit);
				break;
			}
			
			// Block should be visible. Format as appropriate
			switch (content[i].subtype) {
				case "cta":
					// For supportable blogs
					title = document.createElement("h2");
					label = document.createElement("p");
					supportlink = document.createElement("a");
					title.innerText = content[i].title;
					label.innerHTML = content[i].text.replace("%s", `<strong>${blogObj.name}</strong>`);
					supportlink.innerText = blogObj.subscription_plan?.checkout_labels?.support || "Show your Support";
					supportlink.href = content[i].url || `https://www.tumblr.com/${blogObj.name}/support`;
					bit.append(title, label, supportlink);
					break;
				
				case "divider":
					// For creators looking at own +Posts
					bit.classList.add("divider");
					bit.style.setProperty("--color", content[i].color);
					bit.innerText = content[i].text;
					break;
				
				case "disabled":
					// For blogs that have disabled Post+
					title = document.createElement("h2");
					label = document.createElement("p");
					title.innerText = content[i].title;
					label.innerHTML = content[i].text.replace("%s", `<strong>${blogObj.name}</strong>`);
					bit.append(title, label);
					break;
			}
			
			trailItem.append(bit);
			break;

		case "poll":
			bit = document.createElement("div");
			bit.classList.add("poll");
			trailItem.append(bit);

			// Create question, if present
			if (curr.question !== "") {
				let question = document.createElement("p");
				question.classList.add("question");
				question.innerText = curr.question;
				bit.append(question);
			}

			let expiryDate = new Date((curr.timestamp + curr.settings.expire_after) * 1000),
				hasResults = ((new Date()) > expiryDate) && blogViewLink.length;

			// Create answers
			let answer, answerText;
			curr.answers.forEach(a => {
				answer = document.createElement("a");
				answer.classList.add("option");
				if (blogViewLink.length) {
					answer.href = blogViewLink;
					answer.target = "_blank";
				}
				answer.innerHTML = hasResults ? `<span class="material-symbols-outlined">indeterminate_check_box</span>` : `<span class="material-symbols-outlined empty">check_box_outline_blank</span><span class="material-symbols-outlined checked">check_box</span>`;
				answerText = document.createElement("p");
				answerText.innerText = a.answer_text;
				answer.append(answerText);
				bit.append(answer);
			});

			// See results link, if poll is expired
			// Timestamp/expiry durations are given in seconds; times 1000 for millisecond count
			if (hasResults) {
				let seeResults = document.createElement("a");
				seeResults.classList.add("filechip");
				seeResults.href = blogViewLink;
				seeResults.target = "_blank";
				seeResults.innerHTML = `<span class="material-symbols-outlined">bar_chart</span>`;
				seeResults.append("See Results");
				bit.append(seeResults);
				bit.classList.add("complete");
			}
			break;
		
		default:
			bit = document.createElement("p");
			bit.innerHTML = `TODO: ${curr.type} block`;
			trailItem.append(bit);
	
	}
}

/**
 * Helper function for createContentBlock, specifically for audio content blocks.
 * Renders an audio player in a custom style, with pause/play, skip to start/end, muting, and looping functionality.
 * @param {Object} npf The NPF object with links to and data on the audio file.
 * @param {Object} [defaultIcons={}] HTML strings representing the icons to use for the audio player.
 * @param {string} defaultIcons.audio The icon to use for audio files in general, if needed.
 * @param {string} defaultIcons.play The icon to use as the "play" (⏵︎) button.
 * @param {string} defaultIcons.pause The icon to use as the "pause" (⏸︎) button.
 * @param {string} defaultIcons.download The icon to use as the "download" button.
 * @param {string} defaultIcons.mute The icon to use as the "mute" (🔇) button.
 * @param {string} defaultIcons.unmute The icon to use as the "unmute" (🔊) button.
 * @param {string} defaultIcons.repeat The icon to use as the "loop" (🔁) button.
 * @param {string} defaultIcons.unrepeat The icon to use as the "stop looping" button.
 * @returns {HTMLElement} The complete audio element with attached event listeners.
 */
function createCustomAudio(npf, defaultIcons = {}) {
	// #region Basic blocks setup: icons, audio wrapper, and audio
	// Uses Phosphor icons by default
	// All icons need matching classes, except for skip to start/end
	let icons = Object.assign({
		audio: '<span class="material-symbols-outlined">headphones</span>',
		play: '<span class="play material-symbols-outlined">play_arrow</span>',
		pause: '<span class="pause material-symbols-outlined">pause</span>',
		download: '<span class="material-symbols-outlined">download</span>',
		mute: '<span class="mute material-symbols-outlined">volume_up</span>',
		unmute: '<span class="unmute material-symbols-outlined">volume_off</span>',
		repeat: '<span class="repeat material-symbols-outlined">repeat</span>',
		unrepeat: '<span class="unrepeat material-symbols-outlined">repeat_one</span>',
	}, defaultIcons);

	wrapper = document.createElement("div");
	wrapper.classList.add("audiowrapper");

	let audio = document.createElement("audio");
	audio.src = npf.media.url;
	audio.preload = "metadata";
	wrapper.append(audio);
	// #endregion

	// #region Audio information
	let top = document.createElement("div");
	top.classList.add("top");

	let textInfo = document.createElement("div");
	textInfo.classList.add("textinfo");
	if (npf.title) {
		let trackname = document.createElement("span");
		trackname.classList.add("trackname");
		trackname.innerText = npf.title;
		textInfo.append(trackname);
	}
	if (npf.artist) {
		let artist = document.createElement("span");
		artist.classList.add("artist");
		artist.innerText = npf.artist;
		textInfo.append(artist);
	}
	if (npf.album) {
		let album = document.createElement("span");
		album.classList.add("album");
		album.innerText = npf.album;
		textInfo.append(album);
	}
	if (!npf.title && !npf.artist && !npf.album) { textInfo.innerHTML = "<em>No information avaliable</em>" }

	let poster = document.createElement(npf.poster ? "img" : "span");
	poster.classList.add("poster");
	if (npf.poster) {
		poster.src = npf.poster[0].url;
		poster.width = npf.poster[0].width;
		poster.height = npf.poster[0].height;
	}
	else { poster.innerHTML = icons.audio }
	
	top.append(poster, textInfo);
	wrapper.append(top);
	// #endregion

	// #region Audio controls
	let seekbar = document.createElement("input");
	seekbar.type = "range";
	seekbar.min = 0;
	seekbar.setAttribute("value", "0");
	seekbar.max = 100;
	seekbar.classList.add("seekbar");

	let playPause = document.createElement("button");
	playPause.classList.add("playpause");
	playPause.innerHTML = icons.play + icons.pause;
	let times = document.createElement("span"),
		currTime = document.createElement("span"),
		totalTime = document.createElement("span");
	currTime.innerText = "0:00";
	totalTime.innerText = "0:00";
	times.classList.add("times");
	currTime.classList.add("current");
	totalTime.classList.add("total");
	times.append(currTime, " / ", totalTime);
	let volume = document.createElement("button");
	volume.classList.add("volume");
	volume.innerHTML = icons.mute + icons.unmute;
	let loop = document.createElement("button");
	loop.classList.add("loop");
	loop.innerHTML = icons.repeat + icons.unrepeat;
	let download = document.createElement("a");
	download.classList.add("download");
	download.setAttribute("download", "audio");
	download.href = npf.media.url;
	download.innerHTML = icons.download;

	let controls = document.createElement("div");
	controls.classList.add("controls");
	controls.append(playPause, times, seekbar, volume, loop, download);
	wrapper.append(controls);
	// #endregion

	// #region Preload data and set up interactive elements
	// #region Audio length and ending check
	audio.addEventListener("loadedmetadata", () => {
		seekbar.setAttribute("max", audio.duration);
		totalTime.innerText = calculateTime(audio.duration);
	});
	audio.addEventListener("ended", () => {
		if (!audio.loop) { audio.classList.remove("playing") }
		currentlyPlaying = null;
	})
	// #endregion
	// #region Buttons
	playPause.addEventListener("click", () => {
		// Pause any other audio on the page
		if (currentlyPlaying !== null && currentlyPlaying !== audio) {
			currentlyPlaying.pause();
			currentlyPlaying.classList.remove("playing");
			cancelAnimationFrame(rAF); // in case the previous one had an rAF going on
		}
		// Play/pause current audio as necessary
		if (audio.classList.contains("playing")) {
			currentlyPlaying = null;
			audio.pause();
			cancelAnimationFrame(rAF);
		} else {
			currentlyPlaying = audio;
			audio.play();
			requestAnimationFrame(whilePlaying);
		}
		audio.classList.toggle("playing");
	})
	volume.addEventListener("click", () => {
		audio.muted = !audio.muted;
		volume.classList.toggle("active");
	});
	loop.addEventListener("click", () => {
		audio.loop = !audio.loop;
		loop.classList.toggle("active");
	});
	// #endregion
	// #region Seekbar
	const whilePlaying = () => {
		seekbar.value = Math.floor(audio.currentTime);
		currTime.innerText = calculateTime(seekbar.value);
		seekbar.style.setProperty("--progress-width", `${(audio.currentTime / audio.duration) * 100}%`);
		rAF = requestAnimationFrame(whilePlaying);
	}
	seekbar.addEventListener("input", () => {
		currTime.innerText = calculateTime(seekbar.value);
		if (!audio.paused) {
			cancelAnimationFrame(rAF);
		}
	});
	seekbar.addEventListener("change", () => {
		audio.currentTime = seekbar.value;
		seekbar.style.setProperty("--progress-width", `${(audio.currentTime / audio.duration) * 100}%`);
		currTime.innerText = calculateTime(seekbar.value);
		if (!audio.paused) {
			requestAnimationFrame(whilePlaying);
		}
	});
	// #endregion
	// #endregion

	return wrapper;
}


/** Helper for createCustomAudio. Calculates times and returns it in a MM:SS format.
 * Pulled from https://css-tricks.com/lets-create-a-custom-audio-player/
 * @param {number} secs The number of seconds to be converted.
 * @returns {string} The converted time in minutes and seconds.
 */
function calculateTime(secs) {
	let time = {
		minutes: Math.floor(secs / 60),
		seconds: Math.floor(secs % 60),
	}
	time.seconds = time.seconds < 10 ? `0${time.seconds}` : `${time.seconds}`;
	return `${time.minutes}:${time.seconds}`;
}


/**
 * Renders text block content with inline formatting applied.
 * @param {Object} content The NPF object representing this content block.
 * @param {string} content.text The actual string of text to be displayed in this text block.
 * @param {Object[]} content.formatting An array of objects representing formatting applied to this text block, with start/end indices.
 * @returns An HTML string with inline formatting applied.
 */
function formatText(content) {
	let base = content.text;
	if (!content.formatting)
		return base.replaceAll(String.fromCharCode(10), "<br />");
	
	let text = "",
		formats = new Array(),
		i = 0;
	// Manually incrementing i instead of a full for-i loop so that emoji unicode combos aren't split up
	for (const char of base) {
		// open any formatting tags
		formats = content.formatting.filter(f => (f.start === i));
		formats.forEach(f => {
			switch (f.type) {
				case "bold":
					text += "<strong>";
					break;
				case "italic":
					text += "<em>";
					break;
				case "small":
					text += "<small>";
					break;
				case "link":
					text += `<a href='${f.url}'>`;
					break;
				case "mention":
					text += `<a href='${f.blog.url}'>`;
					break;
				case "color":
					text += `<span style='color: ${f.hex};'>`;
					break;
			}
		})
		
		// add the actual character, subbing in linebreaks
		if (char === String.fromCharCode(10)) { text += "<br />" }
		else { text += char }
		
		// close any formatting tags
		formats = content.formatting.filter(f => (f.end === i + 1));
		formats.forEach(f => {
			switch (f.type) {
				case "bold":
					text += "</strong>";
					break;
				case "italic":
					text += "</em>";
					break;
				case "small":
					text += "</small>";
					break;
				case "link":
					text += "</a>";
					break;
				case "mention":
					text += "</a>";
					break;
				case "color":
					text += "</span>";
					break;
			}
		})
		
		i ++;
	}
	return text;
}


// #region Lightbox
/**
 * Creates and opens a lightbox using the images from the target image's trail item.
 */
function triggerLightbox(e) {
	document.body.classList.add("lightboxed");
	comingFrom = e.target;
	
	// Lightboxes only trigger on images in the structure .bodyitemcontent > .row > figure > img.lightboxable (this is also applicable to all images sized >= breakpoint).
	// Lightboxes should only include other lightbox-capable images.
	lightbox = document.createElement("div");
	lightbox.role = "dialog";
	lightbox.setAttribute("aria-modal", "true");
	lightbox.id = "lightbox";
	lightbox.setAttribute("tabindex", "-1");
	Array.from(document.body.children).forEach(el => el.setAttribute("inert", "true"));
	document.body.append(lightbox);
	// Hit Esc to close lightbox
	lightbox.addEventListener("keydown", e => {
		if (e.key === "Escape") {
			// Close lightbox
			lightbox.firstChild.click();
		}
		else if (e.key === "ArrowRight") {
			// Fake key event to advance
			lightbox.querySelector(".center")?.dispatchEvent(new KeyboardEvent("keydown", {"key": "Enter"}));
		}
		else if (e.key === "ArrowLeft") {
			// Fake key event to regress
			lightbox.querySelector(".left")?.dispatchEvent(new KeyboardEvent("keydown", {"key": "Enter"}));
			lightbox.querySelector(".center")?.focus();
		}
	});
	
	// Close lightbox
	let closeButton = document.createElement("div");
	closeButton.id = "close";
	closeButton.setAttribute("tabindex", "0");
	lightbox.prepend(closeButton);
	closeButton.addEventListener("click", closeLightbox);
	closeButton.addEventListener("keydown", e => {
		if (e.key === "Enter" || e.key === " ") { closeLightbox(e) }
	});
	
	// Actual images
	lightboxImages = Array.from(e.target.parentElement.parentElement.parentElement.querySelectorAll("img.lightboxable"));
	lightboxIndex = lightboxImages.findIndex(el => el === e.target);
	let center = e.target.cloneNode();
	center.classList.add("center");
	center.addEventListener("click", interactLightbox);
	center.addEventListener("keydown", interactLightboxKeyboard);
	lightbox.append(center);
	center.focus();
	
	getAdjacentImage("left");
	getAdjacentImage("right");
}

/**
 * Interaction handler for the images in the lightbox. Moves forward/back in the lightbox depending on which image was clicked, or closes the lightbox if out of images.
 * @param {Event} e The event object, to check for type and the image interacted with.
 */
function interactLightbox(e) {
	if (e.target.classList.contains("center")) {
		if (e.target.nextElementSibling) {
			// Has an image to advance to
			
			// Advance to next image
			lightboxIndex ++;
			
			// Delete the left image, if any
			if (e.target.previousElementSibling.classList.contains("left")) {
				e.target.previousElementSibling.remove();
			}
			
			// Move current image to the left
			e.target.classList.remove("center");
			e.target.classList.add("left");
			
			// Move right image to center
			e.target.nextElementSibling.classList.remove("right");
			e.target.nextElementSibling.classList.add("center");
			e.target.nextElementSibling.focus();
			
			// Get new next
			getAdjacentImage("right");
		}
		else if (e.type === "click") {
			// No image to advance to
			// If this is a click event, close the lightbox
			e.target.parentElement.firstChild.click();
		}
	}
	
	else if (e.target.classList.contains("right")) {
		// Advance to next image
		lightboxIndex ++;
		
		// Delete the left image, if any
		if (e.target.previousElementSibling.previousElementSibling.classList.contains("left")) {
			e.target.previousElementSibling.previousElementSibling.remove();
		}
		
		// Move center image to left
		e.target.previousElementSibling.classList.remove("center");
		e.target.previousElementSibling.classList.add("left");
		
		// Move this image to center
		e.target.classList.remove("right");
		e.target.classList.add("center");
		
		// Get new next and focus on it
		getAdjacentImage("right")?.focus();
	}
	
	else { // e.target.classList.contains("left")
		// Go back to previous image
		lightboxIndex --;
		
		// Delete the right image, if any
		if (e.target.nextElementSibling.nextElementSibling) {
			e.target.nextElementSibling.nextElementSibling.remove();
		}
		
		// Move center image to right
		e.target.nextElementSibling.classList.remove("center");
		e.target.nextElementSibling.classList.add("right");
		
		// Move this image to center
		e.target.classList.remove("left");
		e.target.classList.add("center");
		
		// Get new previous and focus on it
		getAdjacentImage("left")?.focus();
	}
}

/**
 * Gets the preceding or succeeding image in the same trail item as the current lightbox image.
 * @param {string} side Which image to get. Either "left" or "right".
 * @returns {?HTMLImageElement} The previous/next image, or null if the current image is the first/last respectively.
 */
 function getAdjacentImage(side) {
	if (side === "left" && lightboxIndex !== 0) {
		let left = lightboxImages[lightboxIndex - 1].cloneNode();
		left.classList.add("left");
		lightbox.firstChild.insertAdjacentElement("afterend", left);
		left.addEventListener("click", interactLightbox);
		left.addEventListener("keydown", interactLightboxKeyboard);
		return left;
	}
	else if (side === "right" && lightboxIndex !== lightboxImages.length - 1) {
		let right = lightboxImages[lightboxIndex + 1].cloneNode();
		right.classList.add("right");
		lightbox.lastChild.insertAdjacentElement("afterend", right);
		right.addEventListener("click", interactLightbox);
		right.addEventListener("keydown", interactLightboxKeyboard);
		return right;
	}
	else {
		return null;
	}
}

/**
 * Triggers lightbox interaction for specific keyboard events, and traps focus inside the lightbox.
 * @param {Event} e The event object, to check for keyboard events and the keys pressed.
 */
function interactLightboxKeyboard(e) {
	if (e.key === "Enter" || e.key === " ") { interactLightbox(e) }
}

/**
 * Closes the active lightbox and returns to the part of the page the lightbox was opened from.
 */
function closeLightbox() {
	document.body.classList.remove("lightboxed");
	lightbox.remove();
	lightboxImages = null;
	lightboxIndex = null;
	lightbox = null;
	// Go back to the image the lightbox was opened from
	Array.from(document.body.children).forEach(el => el.removeAttribute("inert"));
	comingFrom.focus();
}
// #endregion

/**
 * Moves any media at the start of posts to the top of the post body, as in legacy formatting.
 */
function formatLegacyStyle() {
	// Select all special media elements at the very start of posts
	let selector = [
		".bodyitem:first-child .bodyitemcontent > .row:first-child",
		".bodyitem:first-child .bodyitemcontent > video:first-child",
		".bodyitem:first-child .bodyitemcontent > .audiowrapper:first-child",
		".bodyitem:first-child .bodyitemcontent > .npf-link-block:first-child",
		".bodyitem:first-child .bodyitemcontent > iframe:first-child",
	].join(", ");
	
	document.querySelectorAll(selector).forEach(el => {
		// Move el outside its bodyitem into a "mediawrapper" div at the top of the post body
		let bodyitemcontent = el.parentElement,
			wrapper = document.createElement("div");
		wrapper.classList.add("mediawrapper");
		
		// Put wrapper in post body
		// .bodyitemcontent to .bodyitem to .body
		bodyitemcontent.parentElement.parentElement.prepend(wrapper);
		
		// Add this element
		wrapper.prepend(el);
		
		// If this is a photoset element, check for additional rows in the photoset and add them
		if (el.classList.contains("row")) {
			while (bodyitemcontent.childElementCount !== 0 && bodyitemcontent.children[0].classList.contains("row")) {
				wrapper.append(bodyitemcontent.children[0]);
			}
		}
		// Remove the parent body item if it's empty
		if (bodyitemcontent.childElementCount === 0) {
			bodyitemcontent.parentElement.remove();
		}
	})
}
// #endregion

// #region FOR POST NOTES
/**
 * Creates the Notes section for posts on permalink pages.
 * @param {string} notesURL The URL for the HTML partial of this post's Notes.
 */
function createNotes(notesURL) {
	// Create base notes section
	let notes = document.createElement("section"),
		header = document.createElement("h2");
	notes.id = "notes";
	header.textContent = "{lang:Notes}";
	document.getElementById("main").append(notes);

	// Get notes
	var xhttp = new XMLHttpRequest();
	xhttp.onreadystatechange = function(data) {
		if (this.readyState === 4 && this.status === 200) {
			notes.innerHTML = data.srcElement.response;
			cleanNotes();
		}
	}
	xhttp.open("GET", notesURL);
	xhttp.send();

	// Minimize HTML parsing by prepending header after notes partial is added
	notes.prepend(header);
}

/**
 * Cleans newly added notes in the notes section.
 */
function cleanNotes() {
	document.getElementById("notes").querySelectorAll("li:not(.cleaned)").forEach(note => {
		// No cleaning to be done on load more button
		if (note.classList.contains("more_notes_link_container")) { return }

		// Remove avatars and clears
		note.firstChild.remove();
		note.querySelector(".clear").remove();
		
		// Add specific action wrapper
		let acted = document.createElement("span");
		acted.classList.add("acted");
		acted.innerText = note.firstChild.childNodes[1].textContent.trim();
		note.firstChild.childNodes[1].replaceWith(acted);
		
		// Collapse via into reblog action
		if (note.classList.contains("reblog") && !note.classList.contains("original_post")) {
			note.firstChild.childNodes[1].append(note.firstChild.childNodes[2]);
			// Remove "and added:"
			if (note.classList.contains("with_commentary"))
				note.firstChild.childNodes[2].remove();
		}
		
		// Remove colon from "said:"
		else if (note.classList.contains("reply")) {
			note.firstChild.children[1].innerText = note.firstChild.children[1].innerText.substring(0, note.firstChild.children[1].innerText.length - 1)
		}

		// Mark note as cleaned
		note.classList.add("cleaned");
	})
}
function tumblrNotesInserted() { cleanNotes() }
// #endregion

// #region FOR NON-POST PAGES
/**
 * Renders page content on non-post pages.
 * @param {HTMLElement} wrapper The HTML element in which to insert the page content.
 * @param {Object} postData The object containing relevant info with which to populate the page
 * @param {string} postData.title An HTML string containing the title of this page
 * @param {string} postData.body An HTML string containing the body of this page
 */
function createPage(wrapper, postData) {
	let postBody = document.createElement("section");
	postBody.classList.add("body");
	let trailItem = document.createElement("div");
	trailItem.classList.add("bodyitem");
	postBody.append(trailItem);
	wrapper.append(postBody);

	// Create user
	let header = document.createElement("header");
	header.classList.add("user");
	trailItem.append(header);
	// Create permalink
	let link = document.createElement("a");
	link.href = window.location.href; // gives current URL
	header.append(link);
	// Get the username
	let username = document.createElement("span");
	username.classList.add("name");
	username.innerHTML = currentUser.name;
	// put together the header
	link.append(username);
	link.setAttribute("style", `--bg: ${currentUser.theme.background_color}; --text: ${currentUser.theme.title_color}; --accent: ${currentUser.theme.link_color}`)

	// Create title and body of page
	// postData.npf is empty; use exclusively .title and .body
	let bodyWrapper = document.createElement("div");
	bodyWrapper.classList.add("bodyitemcontent");
	if (postData.title) {
		let title = document.createElement(textSubtypes.heading1);
		title.innerHTML = unescapeHTML(postData.title);
		bodyWrapper.append(title);
	}
	bodyWrapper.innerHTML += unescapeHTML(postData.body);

	// Plug the whole thing in
	trailItem.append(bodyWrapper);
}

/**
 * Unescapes HTML strings which have quotations, ampersands, or arrow brackets replaced with HTML entities.
 * @param {string} string The escaped HTML string to unescape.
 * @returns An unescaped version of the provided HTML string, fit for adding to innerHTML.
 */
function unescapeHTML(string) {
	return string.replaceAll("&amp;", "&")
				.replaceAll("&#39;", "'")
				.replaceAll("&quot;", "\"")
				.replaceAll("&lt;", "<")
				.replaceAll("&gt;", ">");
}
// #endregion

// #endregion
</script>


</main>

</body>
</html>