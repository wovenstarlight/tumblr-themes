<!--
	Based on the NPF variable offered by Tumblr.
	https://github.com/tumblr/docs/blob/master/npf-spec.md
-->
<!DOCTYPE html>
<html lang="en">

<head>
	{MobileAppHeaders}
	<meta charset="utf-8">
	<title>{Title}{block:TagPage} ({lang:TagResultCount posts tagged Tag}){/block:TagPage}{block:SearchPage} ({lang:SearchResultCount results for SearchQuery}{block:NoSearchResults}{lang:No results for SearchQuery}{/block:NoSearchResults}){/block:SearchPage}{block:PermalinkPage}{block:PostSummary} — {PostSummary}{/block:PostSummary}{/block:PermalinkPage}</title>
	<meta name="description" content="{MetaDescription}">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="theme-color" content="#35465D">
	<link rel="shortcut icon" href="{Favicon}">
	<link rel="apple-touch-icon-precomposed" href="{PortraitURL-128}">
	<link rel="alternate" type="application/rss+xml" href="{RSS}">
	{block:Hidden}
	<!-- TODO: Custom variables -->
	{/block:Hidden}
	{block:IfSyntaxHighlighting}
	<link rel="stylesheet" href="https://static.tumblr.com/ehm1tdz/2VWnye81h/tumblr-highlightjs.css">
	{/block:IfSyntaxHighlighting}
	{PostTypographyStyles}

	<style>
	{NewPostStyles}
	/* Colors */
	html {
		--text: {TitleColor};
		--text--rgb: {RGBTitleColor};
		--bg: {BackgroundColor};
		--bg--rgb: {RGBBackgroundColor};
		--accent: {AccentColor};
		--accent--rgb: {RGBAccentColor};
	}
	body {
		background: var(--bg);
		color: var(--text);
	}

	.blog-title {
		font-family: {TitleFont}, "Helvetica Neue", HelveticaNeue, Arial, sans-serif;
		font-weight: {TitleFontWeight};
	}

	a { color: var(--accent) }

	.deactivated.user .name::after {
		content: "deactivated";
		opacity: 0.6;
		margin-left: 0.25em;
	}
	.post {
		border: solid var(--accent);
		margin-block: 1em;
		padding: 0.5em;
	}
	.post:not(.page) { white-space: pre-line }
	.user a {
		display: flex;
		align-items: center;
		gap: 0.4em;
	}
	.user .avatar {
		--size: 2.5em;
		width: var(--size);
		height: var(--size);
		border-radius: 0.25em;
	}
	.user .circle.avatar { border-radius: 100% }
	.user .badges {
		--size: 0.875em;
		flex-grow: 1;
		display: flex;
		align-items: center;
		gap: 0.15em;
		height: var(--size);
	}
	.user .badges span {
		position: relative;
		flex-grow: 1;
		max-width: var(--size);
		height: var(--size);
	}
	.user .badges img {
		width: var(--size);
		height: var(--size);
		max-width: unset;
		filter: drop-shadow(0 0 0.1em var(--bg));
		display: block;
	}
	.user .badges span:not(:last-child) img {
		position: absolute;
		left: 0;
	}
	
	.ask {
		border: solid var(--accent);
		padding: 0.5em;
		white-space: pre-line;
		margin-bottom: 1em;
	}
	.ask .user {
		display: flex;
		align-items: center;
	}
	.ask .user a { margin-inline-end: 0.2em }
	
	img {
		max-width: 100%;
		height: auto;
	}
	figure { margin: 0 }
	.npf-link-block, .npf_row { max-width: 33.75em }

	/* #region Default Tumblr audio block */
	.audiowrapper {
		--box: 5.3125em;
		background-color: var(--accent);
		color: var(--bg);
		display: grid;
		grid-template-columns: 1fr auto;
		min-height: var(--box);
	}
	.audiowrapper .left {
		position: relative;
		display: grid;
		grid-template-columns: var(--box) 1fr;
	}
	.audiowrapper .textinfo {
		display: flex;
		flex-direction: column;
		line-height: 1;
		align-self: center;
		gap: 0.4em;
	}
	.audiowrapper .trackname { font-weight: 700 }
	.audiowrapper .artist, .audiowrapper .album { font-size: 0.875em }
	.audiowrapper .buttons {
		align-self: center;
		justify-self: center;
		display: flex;
		align-items: center;
		justify-content: center;
		text-align: center;
		font: inherit;
		padding: 0.1em;
		border: none;
		background-color: transparent;
		color: inherit;
		position: relative;
		z-index: 2;
		cursor: pointer;
	}
	.audiowrapper audio,
	.audiowrapper audio.playing ~ .left .buttons .play,
	.audiowrapper audio:not(.playing) ~ .left .buttons .pause {
		display: none;
	}
	.audiowrapper .albumart {
		width: var(--box);
		height: max(var(--box), 100%);
		object-fit: cover;
	}

	/* Seekbar styling */
	.seekbar {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		margin: 0;
		background-color: transparent;
		-webkit-appearance: none;
		--progress-bg: rgba(var(--bg--rgb), 0.15);
	}
	.seekbar:focus { outline: none }
	.seekbar::before {
		content: "";
		background-color: var(--progress-bg);
		display: block;
		height: 100%;
		width: var(--progress-width);
		position: absolute;
		top: 0;
		left: 0;
	}

	.seekbar::-webkit-slider-runnable-track {
		background: transparent;
		border: 0;
		width: 100%;
		height: 100%;
		cursor: pointer;
	}
	.seekbar::-webkit-slider-thumb {
		width: 0px;
		height: 0px;
		border: 0;
		cursor: pointer;
		-webkit-appearance: none;
	}

	.seekbar::-moz-range-track {
		background: transparent;
		border: 0;
		width: 100%;
		height: 100%;
		cursor: pointer;
	}
	.seekbar::-moz-range-thumb {
		width: 0px;
		height: 0px;
		border: 0;
		cursor: pointer;
	}
	.seekbar::-moz-range-progress {
		background-color: var(--progress-bg);
		height: 100%;
	}

	.seekbar::-ms-track {
		background: transparent;
		border-color: transparent;
		border-width: 0 0;
		color: transparent;
		width: 100%;
		height: 100%;
		cursor: pointer;
	}
	.seekbar::-ms-fill-lower {
		background: var(--progress-bg);
		border: 0;
	}
	.seekbar::-ms-fill-upper {
		background: transparent;
		border: 0;
	}
	.seekbar::-ms-thumb {
		width: 0px;
		height: 0px;
		border: 0;
		cursor: pointer;
		margin-top: 0px;
		/* Needed to keep the Edge thumb centered */
	}
	/* #endregion */

	/* #region Custom audio block */
	.audiowrapper {
		background-color: var(--bg);
		color: var(--text);
		display: flex;
		flex-direction: column;
	}
	.audiowrapper .top {
		display: flex;
		align-items: center;
		justify-content: center;
		gap: 1em;
		padding: 1em 2em;
	}
	.audiowrapper .hasart {
		background-position: center;
		background-size: cover;
	}
	.audiowrapper .hasart .top {
		backdrop-filter: blur(1em);
		background-color: rgba(var(--bg--rgb), 0.75);
	}
	.audiowrapper .albumart {
		--size: 5em;
		max-width: var(--size);
		max-height: var(--size);
		border-radius: 100%;
	}
	.audiowrapper .textinfo {
		display: flex;
		flex-direction: column;
		line-height: 1;
		align-self: center;
		gap: 0.4em;
	}
	.audiowrapper .textinfo:empty { display: none }
	.audiowrapper .trackname { font-weight: 700 }
	.audiowrapper .artist, .audiowrapper .album { font-size: 0.875em }
	.audiowrapper .buttons {
		padding-block: 0.75em;
		display: flex;
		align-items: center;
		justify-content: center;
		text-align: center;
		line-height: 1;
		gap: 0.5em;
	}
	.audiowrapper .buttons button {
		--size: 2em;
		width: var(--size);
		height: var(--size);
		display: flex;
		align-items: center;
		justify-content: center;
		cursor: pointer;
		font: inherit;
		font-size: 1.25em;
		border: none;
		border-radius: 100%;
		background-color: transparent;
		color: inherit;
	}
	.audiowrapper .buttons button:hover {
		color: rgba(var(--text--rgb), 0.5);
		text-shadow: 0 0 var(--accent);
	}
	.audiowrapper .buttons .playpause {
		background-color: var(--text);
		color: var(--bg);
		margin-inline: 0.25em;
	}
	.audiowrapper .buttons .playpause:hover {
		color: var(--bg);
		text-shadow: unset;
		background-color: var(--accent);
		background-image: linear-gradient(rgba(var(--text--rgb), 0.75), rgba(var(--text--rgb), 0.75))
	}
	.audiowrapper .buttons button.active {
		color: var(--accent);
	}
	.audiowrapper audio,
	.audiowrapper audio.playing ~ .buttons .play,
	.audiowrapper audio:not(.playing) ~ .buttons .pause,
	.audiowrapper .volume.active .mute,
	.audiowrapper .volume:not(.active) .unmute,
	.audiowrapper .loop.active .repeat,
	.audiowrapper .loop:not(.active) .unrepeat {
		display: none;
	}

	/* Seekbar styling */
	.seekbar {
		width: 100%;
		height: 0.5em;
		margin: 0;
		background-color: rgba(var(--text--rgb), 0.15);
		-webkit-appearance: none;
		--progress-bg: var(--accent);
		position: relative;
	}
	.seekbar:focus { outline: none }
	.seekbar::before {
		content: "";
		background-color: var(--progress-bg);
		display: block;
		height: 100%;
		width: var(--progress-width);
		position: absolute;
		top: 0;
		left: 0;
		cursor: pointer;
	}

	.seekbar::-webkit-slider-runnable-track {
		background: transparent;
		border: 0;
		width: 100%;
		height: 100%;
		cursor: pointer;
	}
	.seekbar::-webkit-slider-thumb {
		width: 0px;
		height: 0px;
		border: 0;
		cursor: pointer;
		-webkit-appearance: none;
	}

	.seekbar::-moz-range-track {
		background: transparent;
		border: 0;
		width: 100%;
		height: 100%;
		cursor: pointer;
	}
	.seekbar::-moz-range-thumb {
		width: 0px;
		height: 0px;
		border: 0;
		cursor: pointer;
	}
	.seekbar::-moz-range-progress {
		background-color: var(--progress-bg);
		height: 100%;
	}

	.seekbar::-ms-track {
		background: transparent;
		border-color: transparent;
		border-width: 0 0;
		color: transparent;
		width: 100%;
		height: 100%;
		cursor: pointer;
	}
	.seekbar::-ms-fill-lower {
		background: var(--progress-bg);
		border: 0;
	}
	.seekbar::-ms-fill-upper {
		background: transparent;
		border: 0;
	}
	.seekbar::-ms-thumb {
		width: 0px;
		height: 0px;
		border: 0;
		cursor: pointer;
		margin-top: 0px;
		/* Needed to keep the Edge thumb centered */
	}
	/* #endregion */

	/* Custom CSS */
	{CustomCSS}
	</style>
</head>



<body class="{block:IndexPage} index-page{/block:IndexPage}{block:PermalinkPage} permalink{/block:PermalinkPage}{block:LikesPage} likes-page{/block:LikesPage}{block:FollowingPage} following-page{/block:FollowingPage}{block:SearchPage} search-page{block:NoSearchResults} no-results{/block:NoSearchResults}{block:NoLikes} no-likes{/block:NoLikes}{block:NoPosts} no-posts{/block:NoPosts}{block:NoFollowing} no-following{/block:NoFollowing}{/block:SearchPage}">


<main id="main">

	<section id="posts">
		<noscript><article>Javascript is required to view this blog. Please enable scripting and reload.</article></noscript>
	</section>


<script>
// #region CONSTANTS AND GLOBAL VARIABLES
// for when the current blog made/added to a post
const currentUser = {
	name: {JSName},
	title: {JSTitle},
	description: {JSDescription},
	avatar: {JSPortraitURL-64},
	url: {JSBlogURL},
	active: true,
	theme: {
		avatar_shape: {JSAvatarShape},
	},
}

// default tags to wrap things in
const textSubtypes = {
	"heading1": "h2",
	"heading2": "h3",
	"quirky": "p",
	"quote": "p",
	"indented": "blockquote",
	"chat": "p",
	"ordered-list-item": "li",
	"unordered-list-item": "li",
}

// for broken blog trail items. use size 64 avatars!
const anonAvatar = "https://assets.tumblr.com/images/anonymous_avatar_64.gif";
const defaultAvatars = [
	"https://assets.tumblr.com/images/default_avatar/cone_closed_64.png",
	"https://assets.tumblr.com/images/default_avatar/cone_open_64.png",
	"https://assets.tumblr.com/images/default_avatar/cube_closed_64.png",
	"https://assets.tumblr.com/images/default_avatar/cube_open_64.png",
	"https://assets.tumblr.com/images/default_avatar/sphere_closed_64.png",
	"https://assets.tumblr.com/images/default_avatar/sphere_open_64.png",
]
let brokenIcons = {};

// for use in trail item body construction
let bit,	// the base element - a paragraph, blockquote, etc. as drawn from textSubtypes
	list;	// parent element for list items. null when no list is being constructed

// for audio posts specifically
let rAF = null,	// for the requestAnimationFrame calls
	currentlyPlaying = null;
// #endregion



// #region POST CREATION
// #region Post array declaration
let posts = [
	{block:Posts}
	{
		npf: {NPF},

		// For ask/submit/general blog pages
		{block:Title} title: {JSTitle}, {/block:Title}
		body: {JSBody},

		{block:Date}
		// Post-specific items

		id: {JSPostID},
		permalink: {JSPermalink},
		
		date: {
			day: {JSDayOfWeek},
			textDM: "{DayOfMonth} {Month}, {Year}",
			numDM: "{DayOfMonth}/{MonthNumber}/{Year}",
			textMD: "{Month} {DayOfMonth}, {Year}",
			numMD: "{MonthNumber}/{DayOfMonth}/{Year}",
			textDMZ: "{DayOfMonthWithZero} {Month}, {Year}",
			numDMZ: "{DayOfMonthWithZero}/{MonthNumberWithZero}/{Year}",
			textMDZ: "{Month} {DayOfMonthWithZero}, {Year}",
			numMDZ: "{MonthNumberWithZero}/{DayOfMonthWithZero}/{Year}",
			time12: "{12Hour}:{Minutes} {CapitalAmPm}",
			time24: "{24Hour}:{Minutes}",
			time12Z: "{12HourWithZero}:{Minutes} {CapitalAmPm}",
			time24Z: "{24HourWithZero}:{Minutes}",
			url: "/day/{Year}/{MonthNumberWithZero}/{DayOfMonthWithZero}",
		},

		{block:PinnedPostLabel} pinned: {JSPinnedPostLabel}, {/block:PinnedPostLabel}

		{block:HasTags} tags: [
			{block:Tags} {
				name: "{Tag}",
				url: {JSTagURL},
			}, {/block:Tags}
		], {/block:HasTags}

		{block:RebloggedFrom}
		via: {
			name: {JSReblogParentName},
			url: {JSReblogParentURL},
			avatar: {JSReblogParentPortraitURL-40},
		},
		source: {
			name: {JSReblogRootName},
			url: {JSReblogRootURL},
			avatar: {JSReblogRootPortraitURL-40},
		},
		{/block:RebloggedFrom}

		{block:NoteCount} noteCount: {JSNoteCountWithLabel}, {/block:NoteCount}
		
		like_html: {JSLikeButton size="30"},
		reblog_url: {JSReblogURL},

		{block:Submission} submission: {
			name: {JSSubmitter},
			url: {JSSubmitterURL},
			avatar: {JSSubmitterPortraitURL-64},
			label: "{lang:Submitted By}",
		}, {/block:Submission}

		{block:ContentSource} contentSource: {
			name: {JSSourceTitle},
			url: {JSSourceURL},
			{block:SourceLogo} logo: {
				url: {JSBlackLogoURL},
				width: {JSLogoWidth},
				height: {JSLogoHeight},
			}, {/block:SourceLogo}
		}, {/block:ContentSource}

		{/block:Date}
	},
	{/block:Posts}
];
// #endregion
let postContainer = document.getElementById("posts");
posts.forEach(post => {
	let article = document.createElement("article");
	article.classList.add("post");
	postContainer.append(article);

	if ((post.npf.content.length === 0 && post.npf.trail.length === 0) {block:AskPage}|| true{/block:AskPage}{block:SubmitPage}|| true{/block:SubmitPage}) {
		article.classList.add("page");
		createPage(article, post);
		return;
	}

	createPostHeader(article, post);

	let postBody = document.createElement("section");
	postBody.classList.add("body");
	article.append(postBody);
	// Create each reblog of the post
	if (!post.npf.trail.length) { article.classList.add("original") }
	else { post.npf.trail.forEach(trailItem => createTrailItem(postBody, trailItem, null)) }
	// End with the current blog's addition, if any, and expand if on the permalink page
	if (post.npf.content.length) {
		createTrailItem(
			postBody,
			post.npf,
			post.id
			{block:PermalinkPage}, true{/block:PermalinkPage}
		);
	}

	createPostFooter(article, post);
});
// #endregion



// #region CONSTRUCTOR FUNCTIONS

// #region FOR POST HEADER/FOOTER
function createPostHeader(wrapper, postData) {
	let header = document.createElement("header");
	wrapper.append(header);

	// Populate post header
	makeDate(header, postData);

	makePin(header, postData);

	makeContentSource(header, postData);

	makeSubmitter(header, postData);
}

function createPostFooter(wrapper, postData) {
	let footer = document.createElement("footer");
	wrapper.append(footer);
	
	// Populate post footer
	let vsn = document.createElement("span");
	vsn.classList.add("vsn");
	footer.append(vsn);
	makeNoteCount(vsn, postData);
	makeViaSource(vsn, postData);

	let lr = document.createElement("span");
	lr.classList.add("lr");
	footer.append(lr);
	makeLike(lr, postData);
	makeReblog(lr, postData);

	makeTags(footer, postData);
}

// #region Helpers
function makeLike(wrapper, postData, icon = null) {
	// Make element
	let likeButton = document.createElement("a");
	likeButton.href = "#";
	likeButton.classList.add("customlike");
	likeButton.innerHTML = postData.like_html;
	wrapper.append(likeButton);
	
	// Icon or text, as needed
	let label = `<span class="to-like">{block:English}Like{/block:English}{block:German}Liken{/block:German}{block:French}J'aime{/block:French}{block:Italian}Mi piace{/block:Italian}{block:Japanese}スキ{/block:Japanese}{block:Turkish}Beğen{/block:Turkish}{block:Spanish}Me gusta{/block:Spanish}{block:Russian}Нравится{/block:Russian}{block:Polish}Lubię{/block:Polish}{block:PortuguesePT}Gostar{/block:PortuguesePT}{block:PortugueseBR}Curtir{/block:PortugueseBR}{block:Dutch}Vind ik leuk{/block:Dutch}{block:Korean}좋아요{/block:Korean}{block:ChineseSimplified}喜欢{/block:ChineseSimplified}{block:ChineseTraditional}喜歡{/block:ChineseTraditional}{block:ChineseHK}喜歡{/block:ChineseHK}{block:Indonesian}Suka{/block:Indonesian}{block:Hindi}पसंद करें{/block:Hindi}</span>`;
	if (icon !== null) {
		// Assumes icon is an HTML string
		likeButton.innerHTML += icon;
		likeButton.title = label;
	}
	else {
		// No icon provided; use text labels
		// Like text
		likeButton.innerHTML += label;
		// Unlike text
		likeButton.innerHTML += `<span class="to-unlike">{block:English}Unlike{/block:English}{block:German}Entliken{/block:German}{block:French}Je n'aime plus{/block:French}{block:Italian}Non mi piace{/block:Italian}{block:Japanese}スキ解除{/block:Japanese}{block:Turkish}Beğenme{/block:Turkish}{block:Spanish}Ya no me gusta{/block:Spanish}{block:Russian}Не нравится{/block:Russian}{block:Polish}Nie lubię{/block:Polish}{block:PortuguesePT}Deixar de gostar{/block:PortuguesePT}{block:PortugueseBR}Curtir (desfazer){/block:PortugueseBR}{block:Dutch}Vind ik niet meer leuk{/block:Dutch}{block:Korean}좋아요 취소{/block:Korean}{block:ChineseSimplified}取消喜欢{/block:ChineseSimplified}{block:ChineseTraditional}收回喜歡{/block:ChineseTraditional}{block:ChineseHK}收回喜歡{/block:ChineseHK}{block:Indonesian}Tidak Suka{/block:Indonesian}{block:Hindi}पसंद हटाएँ{/block:Hindi}</span>`;
	}
}

function makeReblog(wrapper, postData, icon = null) {
	// Make element
	let reblogButton = document.createElement("a");
	reblogButton.href = postData.reblog_url;
	reblogButton.classList.add("customreblog");
	wrapper.append(reblogButton);

	// Icon or text, as needed
	let label = "{block:English}Reblog{/block:English}{block:German}Rebloggen{/block:German}{block:French}Rebloguer{/block:French}{block:Italian}Reblogga{/block:Italian}{block:Japanese}リブログ{/block:Japanese}{block:Turkish}Yeniden Blogla{/block:Turkish}{block:Spanish}Rebloguear{/block:Spanish}{block:Russian}Реблог{/block:Russian}{block:Polish}Rebloguj{/block:Polish}{block:PortuguesePT}Reblogar{/block:PortuguesePT}{block:PortugueseBR}Reblogar{/block:PortugueseBR}{block:Dutch}Rebloggen{/block:Dutch}{block:Korean}리블로그{/block:Korean}{block:ChineseSimplified}转发{/block:ChineseSimplified}{block:ChineseTraditional}轉格{/block:ChineseTraditional}{block:ChineseHK}轉載{/block:ChineseHK}{block:Indonesian}Reblog{/block:Indonesian}{block:Hindi}रीब्लॉग करें{/block:Hindi}";
	if (icon !== null) {
		reblogButton.innerHTML = icon;
		reblogButton.title = label;
	}
	else {
		reblogButton.innerText = label;
	}
}

function makePin(wrapper, postData, icon = null) {
	if (!postData.pinned) { return; }
	// Make element
	let pin = document.createElement("span");
	pin.id = "pinnedpost";
	wrapper.append(pin);
	// Icon or text, as needed
	if (icon !== null) {
		pin.innerHTML = icon;
		pin.title = postData.pinned;
	}
	else {
		pin.innerText = postData.pinned;
	}
}

function makeViaSource(wrapper, postData, icons = false) {
	if (!postData.via) { return; }
	// Viasource container
	let vs = document.createElement("span");
	vs.classList.add("viasource");
	wrapper.append(vs);

	// Via and source links
	let via = document.createElement("a"),
		source = document.createElement("a");

	// Via URL always exists; add
	via.href = postData.via.url;
	vs.append(via);

	// Check if source blog/post still exists
	let sourceTrail = postData.npf.trail[0];
	if (sourceTrail?.blog) {
		source.href = sourceTrail.blog.url.concat(sourceTrail.blog.url.endsWith("/") ? `post/${sourceTrail.post.id}` : `/${sourceTrail.post.id}`);
		vs.append(source);
	}
	else if (postData.source.url !== "") {
		source.href = postData.source.url;
		vs.append(source);
	}

	// Icons or text, as needed
	if (icons) {
		via.innerHTML = `<img src="${postData.via.avatar}" />`;
		via.title = "{lang:Via}";
		// This might end up being undefined, if the source is broken, but since it isn't added it won't make a difference
		source.innerHTML = `<img src="${sourceTrail.blog?.avatar?.at(3)?.url}" />`;
		source.title = "{lang:Source}";
	}
	else {
		via.innerText = "{lang:Via}";
		source.innerText = "{lang:Source}";
	}
}

function makeNoteCount(wrapper, postData) {
	if (!postData.noteCount) { return; }
	let notes = document.createElement("a");
	notes.href = postData.permalink.concat("#notes");
	notes.classList.add("notecount");
	notes.innerText = postData.noteCount;
	wrapper.append(notes);
}

function makeTags(wrapper, postData, tagOptions = {}) {
	if (!postData.tags) { return; }
	let options = Object.assign({
		span: false,
		commas: false,
		hashtags: true,
	}, tagOptions);
	// Make element
	let tags = document.createElement(options.span ? "span" : "p");
	tags.classList.add("tags");
	// Populate with each tag
	let tagList = postData.tags.map(tag => `<a href="${tag.url}">`.concat(options.hashtags ? "#" : "",`${tag.name}</a>`));
	tags.innerHTML = tagList.join(options.commas ? ", " : "");
	wrapper.append(tags);
}

function makeDate(wrapper, postData, dateOptions = {}) {
	let options = Object.assign({
		includeDay: false,
		dateFormat: "textDM",
		includeTime: false,
		timeFormat: "12",
		commaSeparate: true,
	}, dateOptions),
		date = document.createElement("a");
	// Make element
	date.href = postData.permalink;
	date.classList.add("date");
	wrapper.append(date);
	// Add day, as needed
	if (options.includeDay) {
		date.innerText = postData.date.day.concat(", ");
	};
	// Add date
	date.innerText += postData.date[options.dateFormat];
	// Add time, as needed
	if (options.includeTime) {
		date.innerText += commaSeparate ? ", " : " at ";
		date.innerText += postData.date[`time${options.timeFormat}`];
	}
}

function makeSubmitter(wrapper, postData, label = true, avatar = false) {
	if (!(subData = postData.submission)) { return; }
	let sublabel = document.createElement("span");
	sublabel.classList.add("sublabel");
	wrapper.append(sublabel);
	// Include avatar?
	if (avatar) { sublabel.innerHTML = `<img src="${subData.avatar}" />` }
	// Submitter name, with link to blog if provided
	if (subData.url.length) {
		sublabel.innerHTML += subData.label.replace(subData.name, `<a href="${subData.url}">${subData.name}</a>`);
	}
	else {
		sublabel.innerHTML += subData.label.replace(subData.name, `<a>${subData.name}</a>`);
	}
}

function makeContentSource(wrapper, postData, label = true, logo = false) {
	if (!(sourceData = postData.contentSource)) { return; }
	let source = document.createElement("span");
	source.classList.add("source");
	wrapper.append(source);
	// Include label?
	if (label) { source.innerText = "{lang:Source}: " }
	// Display as...
	if (logo && sourceData.logo) {
		// Image, no text
		source.innerHTML += `<a href="${sourceData.url}"><img src="${sourceData.logo.url}" width="${sourceData.logo.width}" height="${sourceData.logo.height}" alt="${sourceData.name}" /></a>`;
	}
	else {
		// Text, no image
		source.innerHTML += `<a href="${sourceData.url}">${sourceData.name}</a>`;
	}
}
// #endregion
// #endregion

// #region FOR POST BODY
// Each individual blog's contribution to a post
function createTrailItem(post, npf, postID, expand = false) {
	let item = document.createElement("div");
	item.classList.add("bodyitem");
	post.append(item);
	
	// extant blog; create directly
	if (npf.blog !== undefined) { createTrailItemHeader(item, npf.blog, npf.post) }
	
	// deleted/unrecoverable blog; provide an anon avatar
	else if (npf.broken_blog_name !== undefined) {
		brokenIcons[npf.broken_blog_name] ??= defaultAvatars[Math.floor(Math.random() * defaultAvatars.length)];
		createTrailItemHeader(item, {
			name: npf.broken_blog_name,
			avatar: brokenIcons[npf.broken_blog_name]
		});
	}
	
	// blog is currentUser; provide directly-pulled info
	else { createTrailItemHeader(item, currentUser, { id: postID }) }
	
	// create the body of their contribution
	createTrailItemBody(item, npf, { id: postID }, expand);
}


// Link to the post version on the contributing blog
function createTrailItemHeader(trailItem, blogData, postData = null) {
	let header = document.createElement("header");
	header.classList.add("user");
	trailItem.append(header);
	let link = document.createElement("a");
	header.append(link);
	
	// mark broken trail items
	if (postData === null || blogData.active === false) { header.classList.add("deactivated") }
	
	// add link where original posts exist
	if (blogData.url && blogData.active) {
		link.href = blogData.url.concat(blogData.url.endsWith("/") ? `post/${postData.id}` : `/${postData.id}`);
	}
	
	// Get the username and avatar
	let username = document.createElement("span");
	username.classList.add("name");
	username.innerHTML = blogData.name;
	// Generally an active user's nested size-64 URL (index 3 of [512,128,96,64]), or a direct URL for currentUser or anon/broken users
	// The array blog.avatar isn't available sometimes, so include a backup avatar fetch via API
	let avatar = document.createElement("img");
	avatar.classList.add("avatar", blogData?.theme?.avatar_shape || "square");
	avatar.src = blogData.avatar?.at(3)?.url || blogData.avatar || `https://api.tumblr.com/v2/blog/${blogData.name}/avatar/64`;

	// put together the header
	link.append(avatar, username);

	// Checkmarks and other badges, pulled from tumblrmart_accessories
	// https://assets.tumblr.com/images/tumblrmart/badges/blue-checkmark/1.png
	// https://assets.tumblr.com/images/tumblrmart/badges/rainbow/1.png , [1-12].png available
	let badges = blogData.tumblrmart_accessories?.badges;
	if (blogData.can_show_badges && badges) {
		badges.forEach(group => {
			let badge, badgeWrapper,
				badgegroup = document.createElement("span");
			badgegroup.classList.add("badges");
			link.append(badgegroup);
			badgegroup.classList.add(group.product_group);
			group.urls.forEach((url, index) => {
				badge = document.createElement("img");
				badge.src = url;
				badgeWrapper = document.createElement("span");
				badgeWrapper.append(badge);
				badgegroup.append(badgeWrapper);
			})
		})
	}
}


// Body of each individual user's contribution
function createTrailItemBody(trailItem, npf, postData, expand) {
	let content = npf.content;
	let rows = npf.layout.find(l => l.type === "rows");
	let body = document.createElement("div");
	body.classList.add("bodyitemcontent");
	trailItem.append(body);

	for (let i = 0; i < content.length; i ++) {
		// figure out the content type and create the block based on that
		createContentBlock(
			body, content, i,
			npf.blog !== undefined ? npf.blog.blog_view_url.concat("/", npf.post.id)
				: npf.broken_blog_name === undefined ? `https://tumblr.com/${currentUser.name}/${postData.id}`
				: "");
		
		// cut off the post and add a readmore, if one is present and you aren't currently on the post's permalink page
		if (i === rows?.truncate_after && !expand) {
			let readmore = document.createElement("a");
			readmore.classList.add("read_more");
			readmore.innerText = "{lang:Read more}";
			let readmorecontainer = document.createElement("p");
			readmorecontainer.classList.add("read_more_container");
			readmorecontainer.append(readmore);
			body.append(readmorecontainer);
			
			let link;
			if (npf.blog !== undefined) { // blog is extant
				link = npf.blog.url.concat(npf.blog.url.endsWith("/") ? `post/${npf.post.id}` : `/${npf.post.id}`);
			} else if (npf.broken_blog_name !== undefined) { // blog is unreachable; no link
				link = null;
			} else { // blog is current user's
				link = currentUser.url.concat(currentUser.url.endsWith("/") ? `post/${postData.id}` : `/${postData.id}`);
			}
			// add link if reachable
			if (link !== null) { readmore.href = link }
			break; // don't render any more post blocks
		}
	}
	
	// All base content blocks are done. Adjust layout
	// Put columns into rows
	if (rows) {
		let offset = 0;
		rows.display.filter(i => (i.blocks.length > 1)).forEach((iRow, index) => {
			// Need to move further columns out of their rows into the first column
			
			// the -offset is because of however many items being put inside rows and therefore being removed from the indices
			let row = body.children[iRow.blocks[0] - offset];
			
			// and now, move the corresponding columns inside the row
			// skipping the first element, which is already in the row
			for (let i = 1; i < iRow.blocks.length; i ++) {
				// Move next column into row
				row.append(row.nextElementSibling.children[0]);
				// Delete now-empty next row
				row.nextElementSibling.remove();
			}
			offset += iRow.blocks.length - 1;
		})
	}
	
	// If there's an ask, separate it from its answer, if any
	let askNPF = npf.layout.find(l => l.type === "ask");
	if (askNPF) {
		// Anon or not?
		let asker = document.createElement("header");
		asker.classList.add("user");
		let askerName = document.createElement("a");
		let askerIcon = document.createElement("img");
		askerIcon.classList.add("avatar");
		askerName.append(askerIcon);
		if (askNPF.attribution) {
			askerIcon.src = askNPF.attribution.blog.avatar?.at(3)?.url || `https://api.tumblr.com/v2/blog/${askNPF.attribution.blog.name}/avatar/64`;
			askerIcon.classList.add(askNPF.attribution.blog.theme.avatar_shape || "square");
			askerName.href = askNPF.attribution.blog.url;
			askerName.append(askNPF.attribution.blog.name);
			askerName.classList.add("name");
		}
		else {
			askerIcon.src = anonAvatar;
			askerName.append("Anonymous");
		}
		asker.append(askerName, " asked:");
		
		let ask = document.createElement("div");
		ask.classList.add("ask");
		ask.append(asker);
		let askBody = document.createElement("div");
		askBody.classList.add("bodyitemcontent");
		ask.append(askBody);
		
		if (rows) {
			// Blocks may already be nested in rows; count off how many should be in the ask
			let i = askNPF.blocks.length;
			while (i > 0) {
				i -= Math.max(1, body.children[0].childElementCount);
				askBody.append(body.children[0]);
			}
		}
		else {
			// just a simple stack. take however many off the top and put them in the ask
			askNPF.blocks.forEach(b => askBody.append(body.children[0]));
		}
		
		// PLACEMENT OPTIONS (note, none of these are inside .bodyitemcontent!):
		// In root post body, above answer trail item
		trailItem.parentElement.insertBefore(ask, trailItem);
		// Inside same trail item, above answerer's name
		// trailItem.insertBefore(ask, body.previousElementSibling);
		// Inside same trail item, below answerer's name
		// trailItem.insertBefore(ask, body);
	}
}


// Create an individual element in a trail item
function createContentBlock(trailItem, content, i, blogViewLink = "") {
	let curr = content[i];
	switch (curr.type) {
		
		case "text":
			bit = document.createElement(textSubtypes[curr.subtype] || "p");
			
			bit.innerHTML = formatText(curr);
			
			if (curr.subtype?.includes("ordered-list-item")) {
				// if first bullet point of a type, start a new list
				if (content[i - 1]?.subtype !== curr.subtype) {
					if (list) { trailItem.append(list); }
					list = document.createElement(curr.subtype === "ordered-list-item" ? "ol" : "ul")
				}
				
				list.append(bit); // continue the list
				
				// if last item in the list, or a last list, end the list and add the whole thing
				if (content[i + 1]?.subtype !== curr.subtype || i + 1 === content.length) {
					trailItem.append(list);
					list = null;
				}
			}
			else if ( ["quirky", "quote", "indented", "chat"].includes(curr.subtype) ) {
				bit.classList.add("npf_".concat(curr.subtype));
				trailItem.append(bit);
			}
			// otherwise it's a simple paragraph or blockquote or whatever. add
			else { trailItem.append(bit) }
			
			break;
		
		case "image":
			let breakpoint = 300;
			// wrappers
			// for some reason this breaks if col/row are also in the >=540 block
			let row = document.createElement("div");
			row.classList.add("npf_row");
			let col = document.createElement("div");
			col.classList.add("npf_col");
			let fig = document.createElement("figure");
			if (curr.media[0].width >= breakpoint) {
				fig.classList.add("tmblr-full");
			}
			
			// actual image
			bit = document.createElement("img");
			bit.src = curr.media[0].url;
			bit.width = curr.media[0].width;
			bit.height = curr.media[0].height;
			// add alt text, if present
			if (curr.alt_text) { bit.setAttribute("alt", curr.alt_text) }
			// include colors, if present
			for (color in curr.colors) {
				bit.setAttribute("data-".concat(color), "#".concat(curr.colors[color]));
			}
			// nest the structure and append it to the post
			fig.append(bit);
			if (curr.media[0].width >= breakpoint) {
				col.append(fig);
				row.append(col);
				trailItem.append(row);
			}
			else {
				trailItem.append(fig);
			}
			
			if (curr.caption) { // add caption, if present
				let caption = document.createElement("p");
				caption.innerText = curr.caption;
				fig.insertBefore(caption, bit.nextElementSibling);
			}
			
			if (curr.attribution) {
				let attrib = document.createElement("p");
				attrib.classList.add("tmblr-attribution");
				switch (curr.attribution.type) {
					case "post":
						attrib.innerHTML = `<a href="${curr.attribution.url}">{lang:Via} ${curr.attribution.blog.name}</a>`;
						break;
					case "link":
						attrib.innerHTML = `<a href="${curr.attribution.url}">{lang:Source}</a>`;
						break;
				}
				fig.insertBefore(attrib, bit.nextElementSibling);
			}
			break;
		
		case "link":
			bit = document.createElement("div");
			bit.classList.add("npf-link-block");
			let link = document.createElement("a");
			let poster;
			if (curr.poster) {
				bit.classList.add("has-poster");
				poster = document.createElement("div");
				poster.classList.add("poster");
				poster.style.backgroundImage = `url(${curr.poster[0].url})`;
				link.append(poster);
			} else {
				bit.classList.add("no-poster");
			}
			if (curr.title) {
				let title = document.createElement("div");
				title.classList.add("title");
				title.innerText = curr.title;
				if (curr.poster) { poster.append(title) }
				else { link.append(title) }
			}
			let bottom = document.createElement("div");
			bottom.classList.add("bottom");
			if (curr.description) {
				let desc = document.createElement("div");
				desc.classList.add("description");
				desc.innerText = curr.description;
				bottom.append(desc);
			}
			// get "site name" - just the base url without the https
			let sitename = document.createElement("div");
			sitename.classList.add("site-name");
			// use display url if sitename is absent, as in older links
			sitename.innerText = curr.site_name ? curr.site_name : curr.display_url;
			bottom.append(sitename);
			
			link.append(bottom);
			link.href = curr.url;
			bit.append(link);
			trailItem.append(bit);
			break;
		
		case "audio":
			if (curr.media) {
				// Use media object to display default Tumblr audio player
				bit = createTumblrAudio(curr);

				// ...or, display a custom player with more options
				// bit = createCustomAudio(curr);
			}
			// TODO: else if client side SDK... need examples of metadata object
			// If embeds are present, use those
			else if (curr.embed_html) {
				bit = document.createElement("div");
				bit.innerHTML = curr.embed_html.trim();
				bit = bit.firstChild;
			}
			else if (curr.embed_url) {
				bit = document.createElement("iframe");
				bit.title = `Audio: ${curr.title || "Unknown title"} — ${curr.artist || "Unknown artist"}`;
				if (curr.album) { bit.title += ` (<em>${curr.album}</em>)` }
				bit.src = curr.embed_url;
				bit.width = "100%";
			}
			else {
				// All else failed; display a plain link to given URL
				bit = document.createElement("a");
				bit.href = curr.url;
				bit.innerText = `${curr.title || "Unknown title"} — ${curr.artist || "Unknown artist"}`;
				if (curr.album) { bit.innerHTML += `, <em>${curr.album}</em>` }
			}
			trailItem.append(bit);
			break;
		
		// TODO
		// case "video":

		// TODO?
		// case "paywall":

		case "poll":
			bit = document.createElement("div");
			bit.classList.add("poll-post");
			trailItem.append(bit);

			// Create question, if present
			if (curr.question !== "") {
				let question = document.createElement("p");
				question.classList.add("poll-question");
				question.innerText = curr.question;
				bit.append(question);
			}

			// Create answers
			let answer, answerText;
			curr.answers.forEach(a => {
				answer = document.createElement("a");
				answer.classList.add("poll-row");
				if (blogViewLink.length) {
					answer.href = blogViewLink;
					answer.target = "_blank";
				}
				answerText = document.createElement("p");
				answerText.innerText = a.answer_text;
				answer.append(answerText);
				bit.append(answer);
			});

			// See results link, if poll is expired
			// Timestamp/expiry durations are given in seconds; times 1000 for millisecond count
			let expiryDate = new Date((curr.timestamp + curr.settings.expire_after) * 1000);
			if (((new Date()) > expiryDate) && blogViewLink.length) {
				let seeResults = document.createElement("a");
				seeResults.classList.add("poll-see-results");
				seeResults.href = blogViewLink;
				seeResults.target = "_blank";
				seeResults.innerText = "See Results";
				bit.append(seeResults);
			}
			break;
		
		default:
			bit = document.createElement("p");
			bit.innerHTML = `TODO: ${curr.type} block`;
			trailItem.append(bit);
		
	}
}
// Helpers: create audio blocks
function createTumblrAudio(npf, defaultIcons = {}) {
	// #region Basic blocks setup: icons, audio wrapper, and audio
	let icons = Object.assign({
		play: '<svg class="play" height="1.5em" fill="currentColor" viewBox="18 15 13 16"><path d="M30.592 23.578L19.52 30.3a1 1 0 0 1-1.52-.854V16a1 1 0 0 1 1.519-.855l11.073 6.723a1 1 0 0 1 0 1.71z"></path></svg>',
		pause: '<svg class="pause" height="1.5em" fill="currentColor" viewBox="0 0 24 24"><rect width="4" height="16" x="15" y="4" rx="1"></rect><rect width="4" height="16" x="5" y="4" rx="1"></rect></svg>',
	}, defaultIcons);

	wrapper = document.createElement("div");
	wrapper.classList.add("audiowrapper");

	let audio = document.createElement("audio");
	audio.src = npf.media.url;
	audio.preload = "metadata";
	// #endregion

	// #region Left side: play/pause buttons, title/artist/album info, and seekbar
	let left = document.createElement("div");
	left.classList.add("left");

	let playPause = document.createElement("button");
	playPause.classList.add("buttons");
	playPause.innerHTML = icons.play + icons.pause;

	let textInfo = document.createElement("div");
	textInfo.classList.add("textinfo");
	if (npf.title) { textInfo.innerHTML += `<span class="trackname">${npf.title}</span>` }
	if (npf.artist) { textInfo.innerHTML += `<span class="artist">${npf.artist}</span>` }
	if (npf.album) { textInfo.innerHTML += `<span class="album">${npf.album}</span>` }

	let seekbar = document.createElement("input");
	seekbar.type = "range";
	seekbar.min = 0;
	seekbar.setAttribute("value", "0");
	seekbar.max = 100;
	seekbar.classList.add("seekbar");
	// #endregion

	// #region Preload data and set up interactive elements
	// #region Audio length and ending check
	audio.addEventListener("loadedmetadata", () => {
		seekbar.setAttribute("max", audio.duration);
	});
	audio.addEventListener("ended", () => {
		if (!audio.loop) { audio.classList.remove("playing") }
		currentlyPlaying = null;
	})
	// #endregion
	// #region Play/pause
	playPause.addEventListener("click", () => {
		// Pause any other audio on the page
		if (currentlyPlaying !== null && currentlyPlaying !== audio) {
			currentlyPlaying.pause();
			currentlyPlaying.classList.remove("playing");
			cancelAnimationFrame(rAF); // in case the previous one had an rAF going on
		}
		// Play/pause current audio as necessary
		if (audio.classList.contains("playing")) {
			currentlyPlaying = null;
			audio.pause();
			cancelAnimationFrame(rAF);
		} else {
			currentlyPlaying = audio;
			audio.play();
			requestAnimationFrame(whilePlaying);
		}
		audio.classList.toggle("playing");
	})
	// #endregion
	// #region Seekbar
	const whilePlaying = () => {
		seekbar.value = Math.floor(audio.currentTime);
		seekbar.setAttribute("style", `--progress-width: ${(audio.currentTime / audio.duration) * 100}%`);
		rAF = requestAnimationFrame(whilePlaying);
	}
	seekbar.addEventListener("input", () => {
		if (!audio.paused) {
			cancelAnimationFrame(rAF);
		}
	});
	seekbar.addEventListener("change", () => {
		audio.currentTime = seekbar.value;
		seekbar.setAttribute("style", `--progress-width: ${(audio.currentTime / audio.duration) * 100}%`);
		if (!audio.paused) {
			requestAnimationFrame(whilePlaying);
		}
	});
	// #endregion
	// #endregion

	left.append(playPause, textInfo, seekbar);
	
	wrapper.append(audio, left);

	// Add album art, if any
	if (npf.poster) {
		let art = document.createElement("img");
		art.classList.add("albumart");
		art.src = npf.poster[0].url;
		art.width = npf.poster[0].width;
		art.height = npf.poster[0].height;
		wrapper.append(art);
	}

	return wrapper;
}
function createCustomAudio(npf, defaultIcons = {}) {
	// #region Basic blocks setup: icons, audio wrapper, and audio
	// Uses Phosphor icons by default
	// All icons need matching classes, except for skip to start/end
	let icons = Object.assign({
		play: '<i class="pause ph ph-pause">',
		pause: '</i><i class="play ph ph-play"></i>',
		toStart: '<i class="ph ph-skip-back"></i>',
		toEnd: '<i class="ph ph-skip-forward"></i>',
		mute: '<i class="mute ph ph-speaker-simple-high"></i>',
		unmute: '<i class="unmute ph ph-speaker-simple-slash"></i>',
		repeat: '<i class="repeat ph ph-repeat"></i>',
		unrepeat: '<i class="unrepeat ph ph-repeat-once"></i>',
	}, defaultIcons);

	wrapper = document.createElement("div");
	wrapper.classList.add("audiowrapper");

	let audio = document.createElement("audio");
	audio.src = npf.media.url;
	audio.preload = "metadata";
	wrapper.append(audio);
	// #endregion

	// #region Audio information
	let top = document.createElement("div");
	top.classList.add("top");

	let textInfo = document.createElement("div");
	textInfo.classList.add("textinfo");
	if (npf.title) { textInfo.innerHTML += `<span class="trackname">${npf.title}</span>` }
	if (npf.artist) { textInfo.innerHTML += `<span class="artist">${npf.artist}</span>` }
	if (npf.album) { textInfo.innerHTML += `<span class="album">${npf.album}</span>` }
	if (textInfo.childElementCount > 0) { top.append(textInfo) }

	if (npf.poster) {
		let hasArt = document.createElement("div");
		hasArt.classList.add("hasart");
		hasArt.setAttribute("style", `background-image: url('${npf.poster[0].url}')`);

		let art = document.createElement("img");
		art.classList.add("albumart");
		art.src = npf.poster[0].url;
		art.width = npf.poster[0].width;
		art.height = npf.poster[0].height;

		top.prepend(art);
		hasArt.append(top);
		wrapper.append(hasArt);
	}
	else if (top.childElementCount > 0 ) {
		wrapper.append(top);
	}
	// #endregion

	// #region Audio controls
	let seekbar = document.createElement("input");
	seekbar.type = "range";
	seekbar.min = 0;
	seekbar.setAttribute("value", "0");
	seekbar.max = 100;
	seekbar.classList.add("seekbar");

	let buttons = document.createElement("div");
	buttons.classList.add("buttons");

	let playPause = document.createElement("button");
	playPause.classList.add("playpause");
	playPause.innerHTML = icons.play + icons.pause;
	let skipStart = document.createElement("button");
	skipStart.classList.add("skipstart");
	skipStart.innerHTML = icons.toStart;
	let skipEnd = document.createElement("button");
	skipEnd.classList.add("skipend");
	skipEnd.innerHTML = icons.toEnd;
	let volume = document.createElement("button");
	volume.classList.add("volume");
	volume.innerHTML = icons.mute + icons.unmute;
	let loop = document.createElement("button");
	loop.classList.add("loop");
	loop.innerHTML = icons.loop + icons.unloop;

	buttons.append(volume, skipStart, playPause, skipEnd, loop);

	wrapper.append(seekbar, buttons);
	// #endregion

	// #region Preload data and set up interactive elements
	// #region Audio length and ending check
	audio.addEventListener("loadedmetadata", () => {
		seekbar.setAttribute("max", audio.duration);
	});
	audio.addEventListener("ended", () => {
		if (!audio.loop) { audio.classList.remove("playing") }
		currentlyPlaying = null;
	})
	// #endregion
	// #region Buttons
	playPause.addEventListener("click", () => {
		// Pause any other audio on the page
		if (currentlyPlaying !== null && currentlyPlaying !== audio) {
			currentlyPlaying.pause();
			currentlyPlaying.classList.remove("playing");
			cancelAnimationFrame(rAF); // in case the previous one had an rAF going on
		}
		// Play/pause current audio as necessary
		if (audio.classList.contains("playing")) {
			currentlyPlaying = null;
			audio.pause();
			cancelAnimationFrame(rAF);
		} else {
			currentlyPlaying = audio;
			audio.play();
			requestAnimationFrame(whilePlaying);
		}
		audio.classList.toggle("playing");
	})
	volume.addEventListener("click", () => {
		audio.muted = !audio.muted;
		volume.classList.toggle("active");
	});
	loop.addEventListener("click", () => {
		audio.loop = !audio.loop;
		loop.classList.toggle("active");
	});
	skipStart.addEventListener("click", () => {
		if (audio.classList.contains("playing")) { audio.pause() }
		audio.currentTime = 0;
		seekbar.value = 0;
		seekbar.setAttribute("style", `--progress-width: 0%`);
		if (audio.classList.contains("playing")) { audio.play() }
	});
	skipEnd.addEventListener("click", () => {
		audio.currentTime = audio.duration;
		seekbar.value = audio.duration;
		seekbar.setAttribute("style", `--progress-width: 100%`);
		// Fires "ended" by itself
	});
	// #endregion
	// #region Seekbar
	const whilePlaying = () => {
		seekbar.value = Math.floor(audio.currentTime);
		seekbar.setAttribute("style", `--progress-width: ${(audio.currentTime / audio.duration) * 100}%`);
		rAF = requestAnimationFrame(whilePlaying);
	}
	seekbar.addEventListener("input", () => {
		if (!audio.paused) {
			cancelAnimationFrame(rAF);
		}
	});
	seekbar.addEventListener("change", () => {
		audio.currentTime = seekbar.value;
		seekbar.setAttribute("style", `--progress-width: ${(audio.currentTime / audio.duration) * 100}%`);
		if (!audio.paused) {
			requestAnimationFrame(whilePlaying);
		}
	});
	// #endregion
	// #endregion

	return wrapper;
}


// Applies inline formatting to text blocks
function formatText(content) {
	let base = content.text;
	if (!content.formatting) { return base; }
	let text = "",
		formats = new Array(),
		i = 0;
	// Manually incrementing i instead of a full for-i loop so that emoji unicode combos aren't split up
	for (const char of base) {
		// open any formatting tags
		formats = content.formatting.filter(f => (f.start === i));
		formats.forEach(f => {
			switch (f.type) {
				case "bold":
					text += "<strong>";
					break;
				case "italic":
					text += "<em>";
					break;
				case "small":
					text += "<small>";
					break;
				case "link":
					text += `<a href='${f.url}'>`;
					break;
				case "mention":
					text += `<a href='${f.blog.url}'>`;
					break;
				case "color":
					text += `<span style='color: ${f.hex};'>`;
					break;
			}
		})
		
		// add the actual character
		text += char;
		
		// close any formatting tags
		formats = content.formatting.filter(f => (f.end === i + 1));
		formats.forEach(f => {
			switch (f.type) {
				case "bold":
					text += "</strong>";
					break;
				case "italic":
					text += "</em>";
					break;
				case "small":
					text += "</small>";
					break;
				case "link":
					text += "</a>";
					break;
				case "mention":
					text += "</a>";
					break;
				case "color":
					text += "</span>";
					break;
			}
		})
		
		i ++;
	}
	return text;
}
// #endregion

// #region FOR NON-POST PAGES
function createPage(wrapper, postData) {
	let postBody = document.createElement("section");
	postBody.classList.add("body");
	let trailItem = document.createElement("div");
	trailItem.classList.add("bodyitem");
	postBody.append(trailItem);
	wrapper.append(postBody);

	// Create user
	let header = document.createElement("header");
	header.classList.add("user");
	trailItem.append(header);
	// Create permalink
	let link = document.createElement("a");
	link.href = ""; // gives current URL
	header.append(link);
	// Get the username and avatar
	let username = document.createElement("span");
	username.classList.add("name");
	username.innerHTML = currentUser.name;
	let avatar = document.createElement("img");
	avatar.classList.add("avatar", currentUser.theme.avatar_shape);
	avatar.src = currentUser.avatar;
	// put together the header
	link.append(avatar, username);

	// Create title and body of page
	// postData.npf is empty; use exclusively .title and .body
	let bodyWrapper = document.createElement("div");
	bodyWrapper.classList.add("bodyitemcontent");
	if (postData.title) {
		let title = document.createElement(textSubtypes.heading1);
		title.innerHTML = unescapeHTML(postData.title);
		bodyWrapper.append(title);
	}
	bodyWrapper.innerHTML += unescapeHTML(postData.body);

	// Plug the whole thing in
	trailItem.append(bodyWrapper);
}

function unescapeHTML(string) {
	return string.replaceAll("&amp;", "&")
				.replaceAll("&#39;", "'")
				.replaceAll("&quot;", "\"")
				.replaceAll("&lt;", "<")
				.replaceAll("&gt;", ">");
}
// #endregion

// #endregion
</script>


</main>

</body>
</html>