<!--
	THEME 15: HAUNTED by starlightthemes

	Credits:
		Layout and design inspired by the game Detective Beebo: Night at the Mansion. https://bwobbers.itch.io/detective-beebo-night-at-the-mansion
		Tippy.js tooltips by atomiks: https://atomiks.github.io/tippyjs
		Expanded Tumblr localization by codematurgy: https://github.com/boscoxvi/expandedtumblrlocalization

	Last updated 28 Apr 2025.
-->
<!DOCTYPE html>
<html lang="en" class="{select:Color palette}">

<head>
	{MobileAppHeaders}
	<meta charset="utf-8">
	<title>{block:TagPage}{lang:TagResultCount posts tagged Tag} | {/block:TagPage}{block:SearchPage}{lang:SearchResultCount results for SearchQuery}{block:NoSearchResults}{lang:No results for SearchQuery}{/block:NoSearchResults} | {/block:SearchPage}{block:DayPage}{lang:Posted on DayOfMonth Month Year} | {/block:DayPage}{block:PermalinkPage}{block:PostSummary}{PostSummary} | {/block:PostSummary}{/block:PermalinkPage}{Title}</title>
	<meta name="description" content="{MetaDescription}">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<link rel="shortcut icon" href="{Favicon}">
	<link rel="apple-touch-icon-precomposed" href="{PortraitURL-128}">
	<link rel="alternate" type="application/rss+xml" href="{RSS}">

	{block:Hidden}
	<!-- #region TODO: Custom variables -->
	<!-- Color options -->
	<meta name="select:Color palette" content="house" title="House of Vera">
	<meta name="select:Color palette" content="gallery" title="Art gallery">
	<meta name="select:Color palette" content="city" title="City">
	<meta name="select:Color palette" content="trueending" title="True ending">
	<meta name="select:Color palette" content="train" title="Overnight train">
	<meta name="select:Color palette" content="oliver" title="Beebo">
	<meta name="select:Color palette" content="angel" title="Ángel">
	<meta name="select:Color palette" content="vivi" title="Vivi">
	<meta name="select:Color palette" content="marigold" title="Marigold">
	<meta name="select:Color palette" content="nina" title="Nina">
	<meta name="select:Color palette" content="nadia" title="Nadia">
	<meta name="select:Color palette" content="simon" title="Simon">
	<meta name="select:Color palette" content="owen" title="Owen">
	<meta name="select:Color palette" content="police" title="Police">
	<meta name="select:Color palette" content="custom" title="Custom">
	<!-- Custom palette -->
	<meta name="color:Custom background" content="{BackgroundColor}">
	<meta name="color:Custom text" content="{TitleColor}">
	<meta name="color:Custom accent" content="{AccentColor}">

	<!-- Sidebar options -->
	<meta name="select:Sidebar placement" content="left" title="Left">
	<meta name="select:Sidebar placement" content="right" title="Right">
	<meta name="if:Avatar border" content="1">
	<meta name="if:Random post link" content="1">
	<meta name="if:Archive link" content="1">
	<meta name="if:Search bar" content="1">
	<meta name="text:Search bar title" content="Search blog">

	<!-- Main content options -->
	<meta name="if:Post dates" content="1">
	<meta name="if:Post times" content="1">
	<meta name="if:Dates formatted month first" content="1">
	<meta name="if:24 hour times" content="0">
	<meta name="if:Like buttons" content="1">
	<meta name="if:Reblog buttons" content="1">
	<meta name="if:Day page links" content="1">
	<meta name="if:Post tags" content="1">
	<meta name="if:Show tags on click" content="0">
	<meta name="text:Filtered tags" content="spoiler, spoilers">

	<!-- Other options -->
	<meta name="text:FAQ" content="This will go on your ask page, above your ask box.&NewLine;Add whatever HTML or plain text you want. If you don't want an FAQ, leave this field blank!">
	<!-- #endregion -->
	{/block:Hidden}

	{block:Hidden}<!-- Tippy.js tooltips by atomiks -->{/block:Hidden}
	<script src="https://unpkg.com/@popperjs/core@2"></script>
	<script src="https://unpkg.com/tippy.js@6"></script>

	{block:Hidden}<!-- Standardization of theme styles -->{/block:Hidden}
	<link rel="stylesheet" href="https://wovenstarlight.github.io/tumblr-themes/normalize.min.css">

	{PostTypographyStyles}

	{block:Hidden}<!-- Theme styles -->{/block:Hidden}
	<style>
		/* Variables */
		html {
			--title-font: {TitleFont};
			--title-font-weight: {TitleFontWeight};
			&.custom {
				--bg: {color:Custom background};
				--text: {color:Custom text};
				--accent: {color:Custom accent};
			}
		}

		@font-face {
			font-family: "Nokia";
			src: url("https://static.tumblr.com/h7vugp8/HrPsuxh75/nokiafc22.ttf");
		}

		@font-face {
			font-family: "Squeezed Pixels";
			src: url("https://static.tumblr.com/h7vugp8/BZKsuxh7b/squeezedpixels.ttf");
		}
	</style>
	<link rel="stylesheet" href="https://wovenstarlight.github.io/tumblr-themes/theme15/theme15.min.css">

	<style>{CustomCSS}</style>

	{block:Hidden}<!-- Keyboard navigation -->{/block:Hidden}
	<script src="https://wovenstarlight.github.io/tumblr-themes/keyboardnav.min.js"></script>
</head>



<body class="sidebar{select:Sidebar placement}">
<a href="#main" id="skip">Skip to main content</a>

{block:HideTitle}
{block:Hidden}<!-- Accessibility: HIDDEN TITLE -->{/block:Hidden}
<h1 class="visually-hidden">{Title}</h1>
{/block:HideTitle}


<header id="bloghead">
	<a href="/" id="title">
		{block:ShowAvatar}<img src="{PortraitURL-128}" class="{AvatarShape}{block:IfAvatarBorder} border{/block:IfAvatarBorder}" />{/block:ShowAvatar}
		{block:ShowTitle}<h1>{Title}</h1>{/block:ShowTitle}
	</a>

	<nav id="blognav">
		{block:HideTitle}{block:HideAvatar}<a href="/">{lang:Home}</a>{/block:HideAvatar}{/block:HideTitle}
		<button id="opennotepad" class="{block:Description}{block:ShowDescription}hasdesc{/block:ShowDescription}{/block:Description} {block:HasFeaturedTags}hasfeatured{/block:HasFeaturedTags}">{lang:About}</button>
		{block:AskEnabled}<a href="/ask" class="asklink {block:AskPage}current-page{/block:AskPage}">{AskLabel}</a>{/block:AskEnabled}
		{block:SubmissionsEnabled}<a href="/submit" class="submitlink {block:SubmitPage}current-page{/block:SubmitPage}">{SubmitLabel}</a>{/block:SubmissionsEnabled}
		{block:IfRandomPostLink}<a href="/random" class="randomlink">{lang:Random}</a>{/block:IfRandomPostLink}
		{block:IfArchiveLink}<a href="/archive" class="archivelink">{lang:Archive}</a>{/block:IfArchiveLink}

		{block:HasPages}
		{block:Hidden}<!-- CUSTOM PAGES -->{/block:Hidden}
		{block:Pages}<a href="{URL}" class="{CurrentState}">{Label}</a>{/block:Pages}
		{/block:HasPages}

		{block:Hidden}<!-- #region PAGINATION -->{/block:Hidden}
		{block:Pagination}<section id="pagination">
			<a {block:PreviousPage}href="{PreviousPage}"{/block:PreviousPage} class="prev" data-tippy-content="{lang:Previous page}">
				<svg xmlns="http://www.w3.org/2000/svg" width="6" height="9" viewBox="0 0 6 9" preserveAspectRatio="xMidYMid meet" rendering="crispEdges" fill="currentColor" aria-hidden="true">
					<rect x="0" y="4" width="1" height="1" />
					<rect x="1" y="3" width="1" height="3" />
					<rect x="2" y="2" width="1" height="5" />
					<rect x="3" y="1" width="1" height="7" />
					<rect x="4" y="0" width="2" height="9" />
				</svg>
			</a>
			{block:JumpPagination length="7"}
				{block:CurrentPage}<span id="curr">{PageNumber}</span>{/block:CurrentPage}
				{block:JumpPage}<a href="{URL}">{PageNumber}</a>{/block:JumpPage}
			{/block:JumpPagination}
			<a {block:NextPage}href="{NextPage}"{/block:NextPage} class="next" data-tippy-content="{lang:Next page}">
				<svg xmlns="http://www.w3.org/2000/svg" width="6" height="9" viewBox="0 0 6 9" preserveAspectRatio="xMidYMid meet" rendering="crispEdges" fill="currentColor" aria-hidden="true">
					<rect x="0" y="0" width="2" height="9" />
					<rect x="2" y="1" width="1" height="7" />
					<rect x="3" y="2" width="1" height="5" />
					<rect x="4" y="3" width="1" height="3" />
					<rect x="5" y="4" width="1" height="1" />
				</svg>
			</a>
		</section>{/block:Pagination}

		{block:PermalinkPagination}<section id="pagination">
			<a {block:PreviousPost}href="{PreviousPost}"{/block:PreviousPost} class="prev" data-tippy-content="{lang:Previous post}">
				<svg xmlns="http://www.w3.org/2000/svg" width="6" height="9" viewBox="0 0 6 9" preserveAspectRatio="xMidYMid meet" rendering="crispEdges" fill="currentColor" aria-hidden="true">
					<rect x="0" y="4" width="1" height="1" />
					<rect x="1" y="3" width="1" height="3" />
					<rect x="2" y="2" width="1" height="5" />
					<rect x="3" y="1" width="1" height="7" />
					<rect x="4" y="0" width="2" height="9" />
				</svg>
			</a>
			<span>{lang:See more posts}</span>
			<a {block:NextPost}href="{NextPost}"{/block:NextPost} class="next" data-tippy-content="{lang:Next post}">
				<svg xmlns="http://www.w3.org/2000/svg" width="6" height="9" viewBox="0 0 6 9" preserveAspectRatio="xMidYMid meet" rendering="crispEdges" fill="currentColor" aria-hidden="true">
					<rect x="0" y="0" width="2" height="9" />
					<rect x="2" y="1" width="1" height="7" />
					<rect x="3" y="2" width="1" height="5" />
					<rect x="4" y="3" width="1" height="3" />
					<rect x="5" y="4" width="1" height="1" />
				</svg>
			</a>
		</section>{/block:PermalinkPagination}

		{block:DayPage}{block:DayPagination}<section id="pagination">
			<a {block:PreviousDayPage}href="{PreviousDayPage}"{/block:PreviousDayPage} class="prev" data-tippy-content="{lang:Previous day}">
				<svg xmlns="http://www.w3.org/2000/svg" width="6" height="9" viewBox="0 0 6 9" preserveAspectRatio="xMidYMid meet" rendering="crispEdges" fill="currentColor" aria-hidden="true">
					<rect x="0" y="4" width="1" height="1" />
					<rect x="1" y="3" width="1" height="3" />
					<rect x="2" y="2" width="1" height="5" />
					<rect x="3" y="1" width="1" height="7" />
					<rect x="4" y="0" width="2" height="9" />
				</svg>
			</a>
			<span>{block:IfDatesFormattedMonthFirst}{Month} {DayOfMonth}{DayOfMonthSuffix}{/block:IfDatesFormattedMonthFirst}{block:IfNotDatesFormattedMonthFirst}{DayOfMonth}{DayOfMonthSuffix} {Month}{/block:IfNotDatesFormattedMonthFirst}, {Year}</span>
			<a {block:NextDayPage}href="{NextDayPage}"{/block:NextDayPage} class="next" data-tippy-content="{lang:Next day}">
				<svg xmlns="http://www.w3.org/2000/svg" width="6" height="9" viewBox="0 0 6 9" preserveAspectRatio="xMidYMid meet" rendering="crispEdges" fill="currentColor" aria-hidden="true">
					<rect x="0" y="0" width="2" height="9" />
					<rect x="2" y="1" width="1" height="7" />
					<rect x="3" y="2" width="1" height="5" />
					<rect x="4" y="3" width="1" height="3" />
					<rect x="5" y="4" width="1" height="1" />
				</svg>
			</a>
		</section>{/block:DayPagination}{/block:DayPage}
		{block:Hidden}<!-- #endregion -->{/block:Hidden}
	</nav>

	<dialog id="notepad">
		<section id="notepadtabs">
			{block:Description}{block:ShowDescription}
			<input type="radio" name="nbtabs" id="tab-about" class="visually-hidden" checked>
			<label for="tab-about"><span>{lang:About}</span></label>
			{/block:ShowDescription}{/block:Description}

			{block:HasFeaturedTags}
			<input type="radio" name="nbtabs" id="tab-featured" class="visually-hidden">
			<label for="tab-featured"><span>{lang:Tags}</span></label>
			{/block:HasFeaturedTags}
		</section>

		{block:Description}{block:ShowDescription}
		<section id="about">
			<h2>{Name}</h2>
			<img src="{PortraitURL-128}" {block:IfAvatarBorder}class="border"{/block:IfAvatarBorder} />
			<div id="description">{Description}</div>
		</section>
		{/block:ShowDescription}{/block:Description}

		{block:HasFeaturedTags}
		<section id="featured">
			<h2>Featured tags</h2>
			<ul>
				{block:FeaturedTags}
				<li>
					<span class="name">{Tag}</span>
					<span class="links">
						<a href="{TagURL}">newest first</a>
						<a href="{TagURLChrono}">oldest first</a>
					</span>
				</li>
				{/block:FeaturedTags}
			</ul>
		</section>
		{/block:HasFeaturedTags}

		<button class="closebtn">
			<span class="visually-hidden">Close</span>
			<svg xmlns="http://www.w3.org/2000/svg" width="5" height="5" viewBox="0 0 5 5" preserveAspectRatio="xMidYMid meet" rendering="crispEdges" fill="currentColor" aria-hidden="true">
				<rect x="0" y="0" width="1" height="1" />
				<rect x="1" y="1" width="1" height="1" />
				<rect x="2" y="2" width="1" height="1" />
				<rect x="3" y="3" width="1" height="1" />
				<rect x="4" y="4" width="1" height="1" />
				<rect x="0" y="4" width="1" height="1" />
				<rect x="1" y="3" width="1" height="1" />
				<rect x="3" y="1" width="1" height="1" />
				<rect x="4" y="0" width="1" height="1" />
			</svg>
		</button>
	</dialog>

	{block:IfSearchBar}
	{block:Hidden}<!-- SEARCH BAR -->{/block:Hidden}
	<form action="/search" method="get" id="search" {block:HideFromSearchEnabled}disabled hidden{/block:HideFromSearchEnabled}>
		<i class="ph-magnifying-glass"></i>
		<label for="q" class="visually-hidden">{block:IfSearchBarTitle}{text:Search bar title}{/block:IfSearchBarTitle}{block:IfNotSearchBarTitle}{lang:Search}{/block:IfNotSearchBarTitle}</label>
		<input id="q" type="text" name="q" value="{SearchQuery}" placeholder="{block:IfSearchBarTitle}{text:Search bar title}{/block:IfSearchBarTitle}{block:IfNotSearchBarTitle}{lang:Search}{/block:IfNotSearchBarTitle}"/>
	</form>
	{/block:IfSearchBar}

	<section id="options">
		<button href="#top" id="scrolltotop" disabled>Back to top</button>
	</section>
</header>

<main id="main">

	<section id="posts">
		{block:HomePage}
		{block:Hidden}<!-- STANDARD PAGE HEADER -->{/block:Hidden}
		<hgroup class="page title visually-hidden"><h2>{lang:Posts}</h2></hgroup>
		{/block:HomePage}

		{block:PermalinkPage}
		{block:Hidden}<!-- SPECIAL PAGE HEADER: PERMALINK. also includes ask and submit pages -->{/block:Hidden}
		<hgroup class="page title visually-hidden"><h2>
			{block:AskPage}<span class="ask">{AskLabel}</span>{/block:AskPage}
			{block:SubmitPage}<span class="submit">{SubmitLabel}</span>{/block:SubmitPage}
			<span class="permalink">{lang:Permalink}</span>
		</h2></hgroup>
		{/block:PermalinkPage}

		{block:TagPage}
		{block:Hidden}<!-- PAGE HEADER: TAG -->{/block:Hidden}
		<hgroup class="page title">
			<h2>{lang:TagResultCount posts tagged Tag 2}</h2>
			<p>
				<a href="/tagged/{URLSafeTag}">Newest first</a>
				<a href="/tagged/{URLSafeTag}/chrono">Oldest first</a>
			</p>
		</hgroup>
		{/block:TagPage}

		{block:DayPage}
		{block:Hidden}<!-- PAGE HEADER: DAY -->{/block:Hidden}
		<hgroup class="page title"><h2>{lang:Viewing everything posted on Month DayOfMonth Year}</h2></hgroup>
		{/block:DayPage}

		{block:SearchPage}
		{block:Hidden}<!-- PAGE HEADER: SEARCH -->{/block:Hidden}
		<hgroup class="page title">
			<h2>
				{lang:SearchResultCount results for SearchQuery 2}
				{block:NoSearchResults}{lang:No results for SearchQuery 2}{/block:NoSearchResults}
			</h2>
		</hgroup>
		{/block:SearchPage}

		<noscript><article><p>Javascript is required to view this blog. Please enable scripting and reload.</p></article></noscript>
	</section>

	<dialog id="lightbox">
		<button class="closebtn">
			<span class="visually-hidden">Close</span>
			<svg xmlns="http://www.w3.org/2000/svg" width="5" height="5" viewBox="0 0 5 5" preserveAspectRatio="xMidYMid meet" rendering="crispEdges" fill="currentColor" aria-hidden="true">
				<rect x="0" y="0" width="1" height="1" />
				<rect x="1" y="1" width="1" height="1" />
				<rect x="2" y="2" width="1" height="1" />
				<rect x="3" y="3" width="1" height="1" />
				<rect x="4" y="4" width="1" height="1" />
				<rect x="0" y="4" width="1" height="1" />
				<rect x="1" y="3" width="1" height="1" />
				<rect x="3" y="1" width="1" height="1" />
				<rect x="4" y="0" width="1" height="1" />
			</svg>
		</button>
	</dialog>
</main>

<a id="credit" href="https://starlightthemes.tumblr.com/theme15">{lang:Install this theme}</a>

{block:Hidden}<!-- #region Templates -->{/block:Hidden}
<template id="curlyborder">
	<svg class="separator" xmlns="http://www.w3.org/2000/svg" width="84" height="7" viewBox="0 0 84 7" preserveAspectRatio="xMidYMid meet" rendering="crispEdges" fill="currentColor" aria-hidden="true">
		{block:Hidden}<!-- Left curly -->{/block:Hidden}
		<rect x="5" y="2" width="2" height="1" />
		<rect x="7" y="1" width="1" height="1" />
		<rect x="2" y="0" width="5" height="1" />
		<rect x="1" y="1" width="1" height="1" />
		<rect x="0" y="2" width="1" height="1" />
		<rect x="1" y="3" width="1" height="1" />
		<rect x="2" y="4" width="3" height="1" />
		<rect x="5" y="5" width="14" height="1" />
		<rect x="19" y="4" width="2" height="1" />
		<rect x="21" y="3" width="3" height="1" />
		<rect x="24" y="2" width="4" height="1" />
		<rect x="28" y="1" width="7" height="1" />
		<rect x="35" y="2" width="2" height="1" />
		<rect x="37" y="3" width="1" height="3" />
		<rect x="34" y="6" width="3" height="1" />
		<rect x="33" y="5" width="1" height="1" />
		<rect x="34" y="4" width="2" height="1" />

		{block:Hidden}<!-- Center circle -->{/block:Hidden}
		<rect x="41" y="2" width="2" height="1" />
		<rect x="40" y="3" width="1" height="3" />
		<rect x="43" y="3" width="1" height="3" />
		<rect x="41" y="6" width="2" height="1" />

		{block:Hidden}<!-- Right curly -->{/block:Hidden}
		<rect x="77" y="2" width="2" height="1" />
		<rect x="76" y="1" width="1" height="1" />
		<rect x="77" y="0" width="5" height="1" />
		<rect x="82" y="1" width="1" height="1" />
		<rect x="83" y="2" width="1" height="1" />
		<rect x="82" y="3" width="1" height="1" />
		<rect x="79" y="4" width="3" height="1" />
		<rect x="65" y="5" width="14" height="1" />
		<rect x="63" y="4" width="2" height="1" />
		<rect x="60" y="3" width="3" height="1" />
		<rect x="56" y="2" width="4" height="1" />
		<rect x="49" y="1" width="7" height="1" />
		<rect x="47" y="2" width="2" height="1" />
		<rect x="46" y="3" width="1" height="3" />
		<rect x="47" y="6" width="3" height="1" />
		<rect x="50" y="5" width="1" height="1" />
		<rect x="48" y="4" width="2" height="1" />
	</svg>
</template>

<template id="filtermessage">
	<div class="filter">
		<p>This post contains filtered tags.</p>
		<p class="tags">#filtered tag</p>
		<button>View post</button>
	</div>
</template>

<template id="iconspeaker">
	<svg xmlns="http://www.w3.org/2000/svg" width="5" height="6" viewBox="0 0 5 6" preserveAspectRatio="xMidYMid meet" rendering="crispEdges" fill="currentColor" aria-hidden="true">
		<rect x="1" y="1" width="1" height="1" />
		<rect x="2" y="0" width="1" height="1" />
		<rect x="3" y="1" width="1" height="2" />
		<rect x="2" y="3" width="1" height="1" />
		<rect x="2" y="5" width="1" height="1" />
	</svg>
</template>

{block:Hidden}<!-- Icons below all made by me. -->{/block:Hidden}
<template id="icondate">
	<svg xmlns="http://www.w3.org/2000/svg" width="11" height="9" viewBox="0 0 11 9" preserveAspectRatio="xMidYMid meet" rendering="crispEdges" fill="currentColor" aria-hidden="true">
		<rect x="0" y="1" width="11" height="1"/>
		<rect x="0" y="3" width="11" height="1"/>
		<rect x="0" y="8" width="11" height="1"/>
		<rect x="0" y="1" width="1" height="8"/>
		<rect x="10" y="1" width="1" height="8"/>
		<rect x="2" y="0" width="1" height="1" />
		<rect x="5" y="0" width="1" height="1" />
		<rect x="8" y="0" width="1" height="1" />
	</svg>
</template>

<template id="iconreblog">
	<svg xmlns="http://www.w3.org/2000/svg" width="11" height="11" viewBox="0 0 11 11" preserveAspectRatio="xMidYMid meet" rendering="crispEdges" fill="currentColor" aria-hidden="true">
		<rect x="1" y="8" width="2" height="1"/>
		<rect x="0" y="3" width="1" height="5"/>
		<rect x="1" y="2" width="6" height="1"/>
		<rect x="5" y="1" width="1" height="3"/>
		<rect x="4" y="0" width="1" height="1"/>
		<rect x="4" y="4" width="1" height="1"/>

		<rect x="8" y="2" width="2" height="1"/>
		<rect x="10" y="3" width="1" height="5"/>
		<rect x="4" y="8" width="6" height="1"/>
		<rect x="5" y="7" width="1" height="3"/>
		<rect x="6" y="6" width="1" height="1"/>
		<rect x="6" y="10" width="1" height="1"/>
	</svg>
</template>

<template id="iconlike">
	<svg xmlns="http://www.w3.org/2000/svg" width="11" height="10" viewBox="0 0 11 10" preserveAspectRatio="xMidYMid meet" rendering="crispEdges" fill="currentColor" aria-hidden="true" class="like">
		<rect x="2" y="0" width="2" height="1"/>
		<rect x="7" y="0" width="2" height="1"/>
		<rect x="1" y="1" width="1" height="1"/>
		<rect x="4" y="1" width="1" height="1"/>
		<rect x="6" y="1" width="1" height="1"/>
		<rect x="9" y="1" width="1" height="1"/>
		<rect x="0" y="2" width="1" height="3"/>
		<rect x="5" y="2" width="1" height="1"/>
		<rect x="10" y="2" width="1" height="3"/>
		<rect x="1" y="5" width="1" height="1"/>
		<rect x="9" y="5" width="1" height="1"/>
		<rect x="2" y="6" width="1" height="1"/>
		<rect x="8" y="6" width="1" height="1"/>
		<rect x="3" y="7" width="1" height="1"/>
		<rect x="7" y="7" width="1" height="1"/>
		<rect x="4" y="8" width="1" height="1"/>
		<rect x="6" y="8" width="1" height="1"/>
		<rect x="5" y="9" width="1" height="1"/>
	</svg>
</template>

<template id="iconliked">
	<svg xmlns="http://www.w3.org/2000/svg" width="11" height="10" viewBox="0 0 11 10" preserveAspectRatio="xMidYMid meet" rendering="crispEdges" fill="currentColor" aria-hidden="true" class="liked">
		<rect x="2" y="0" width="2" height="2"/>
		<rect x="7" y="0" width="2" height="2"/>
		<rect x="1" y="1" width="9" height="5"/>
		<rect x="0" y="2" width="11" height="3"/>
		<rect x="2" y="5" width="7" height="2"/>
		<rect x="3" y="6" width="5" height="2"/>
		<rect x="4" y="7" width="3" height="2"/>
		<rect x="5" y="8" width="1" height="2"/>
	</svg>
</template>

<template id="iconlink">
	<svg xmlns="http://www.w3.org/2000/svg" width="10" height="11" viewBox="0 0 11 10" preserveAspectRatio="xMidYMid meet" rendering="crispEdges" fill="currentColor" aria-hidden="true">
		<rect x="4" y="2" width="1" height="1"/>
		<rect x="5" y="1" width="1" height="1"/>
		<rect x="6" y="0" width="3" height="1"/>
		<rect x="9" y="1" width="1" height="3"/>
		<rect x="8" y="4" width="1" height="1"/>
		<rect x="7" y="5" width="1" height="1"/>
		<rect x="4" y="6" width="3" height="1"/>

		<rect x="5" y="8" width="1" height="1"/>
		<rect x="4" y="9" width="1" height="1"/>
		<rect x="1" y="10" width="3" height="1"/>
		<rect x="0" y="7" width="1" height="3"/>
		<rect x="1" y="6" width="1" height="1"/>
		<rect x="2" y="5" width="1" height="1"/>
		<rect x="3" y="4" width="3" height="1"/>
	</svg>
</template>

<template id="iconpin">
	<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 10 10" preserveAspectRatio="xMidYMid meet" rendering="crispEdges" fill="currentColor" aria-hidden="true">
		<rect x="6" y="0" width="1" height="1"/>
		<rect x="7" y="1" width="1" height="1"/>
		<rect x="8" y="2" width="1" height="1"/>
		<rect x="9" y="3" width="1" height="1"/>
		<rect x="5" y="1" width="1" height="2"/>
		<rect x="7" y="4" width="2" height="1"/>
		<rect x="4" y="3" width="1" height="1"/>
		<rect x="6" y="5" width="1" height="1"/>
		<rect x="1" y="4" width="3" height="1"/>
		<rect x="5" y="6" width="1" height="3"/>
		<rect x="2" y="5" width="1" height="1"/>
		<rect x="3" y="6" width="1" height="1"/>
		<rect x="4" y="7" width="1" height="1"/>
		<rect x="2" y="7" width="1" height="1"/>
		<rect x="1" y="8" width="1" height="1"/>
		<rect x="0" y="9" width="1" height="1"/>
	</svg>
</template>

<template id="icontag">
	<svg xmlns="http://www.w3.org/2000/svg" width="11" height="11" viewBox="0 0 11 11" preserveAspectRatio="xMidYMid meet" rendering="crispEdges" fill="currentColor" aria-hidden="true">
		<rect x="3" y="0" width="1" height="11"/>
		<rect x="7" y="0" width="1" height="11"/>
		<rect x="0" y="3" width="11" height="1"/>
		<rect x="0" y="7" width="11" height="1"/>
	</svg>
</template>

<template id="readmore">
	<hr class="readmore" />
</template>
{block:Hidden}<!-- #endregion -->{/block:Hidden}

{block:Hidden}<!-- The actual functionality of the theme. -->{/block:Hidden}
<script>
// #region CONSTANTS AND GLOBAL VARIABLES
/** Information of the blog this theme is being used on. For use when this blog makes/adds to posts.
 */
const currentUser = {
	/** Blog username
	 * @type {string}
	 */
	name: {JSName},
	/** Blog title
	 * @type {string}
	 */
	title: {JSTitle},
	/** Blog description. May contain HTML
	 * @type {string}
	 */
	description: {JSDescription},
	/** URL to the blog avatar, size 128x128
	 * @type {string}
	 */
	avatar: {JSPortraitURL-128},
	/** URL to the blog (in the format https://username.tumblr.com)
	 * @type {string}
	 */
	url: {JSBlogURL},
	/** Whether the blog is active. Always true
	 * @type {boolean}
	 */
	active: true,
	/** Blog theme object. Contains information about colors/blog layout */
	theme: {
		/** Shape of the blog avatar. Either "square" or "circle"
		 * @type {string}
		 */
		avatar_shape: {JSAvatarShape},
		background_color: {JSBackgroundColor},
		title_color: {JSTitleColor},
		link_color: {JSAccentColor},
		title_font: {JSTitleFont},
	},
}

/** Default HTML tags to wrap specific text content block types in.
 * @type {Object.<string, string>}
 */
const textSubtypes = {
	"heading1": "h3",
	"heading2": "h4",
	"quirky": "p",
	"quote": "p",
	"indented": "blockquote",
	"chat": "p",
	"ordered-list-item": "li",
	"unordered-list-item": "li",
}

/** URL to the 128x128 avatar for anonymous, deactivated, or broken users.
 * @type {string}
 */
const anonAvatar = "https://assets.tumblr.com/images/anonymous_avatar_128.gif";

/** For use in trail item body construction. The base element (paragraph, blockquote etc.) as selected from textSubtypes.
 * @type {HTMLElement}
 */
let bit;
/** For use in trail item body construction. The parent element for list items. Null when no list is being constructed.
 * @type {?string}
 */
let list;

/** For use in audio posts. Stores the request ID for the animation frames.
 * @type {?long}
 */
let rAF = null;
/** For use in audio posts. Stores the currently playing audio element, if any.
 * @type {?HTMLElement}
 */
let currentlyPlaying = null;

/*{block:IfFilteredTags}*/
/** For use in tag filtering. The user-provided list of tags to filter for.
 * All tags converted to lowercase for ease of comparison.
 * @type {string[]}
 */
let filteredTags = "{text:Filtered tags}".toLowerCase().split(",").map(el => el.trim());
/** For use in tag filtering. The template for the warning to display over filtered posts.
 */
let filterMessage = document.getElementById("filtermessage").content;
/*{/block:IfFilteredTags}*/

/** Post separation border. */
let postSeparator = document.getElementById("curlyborder").content;

/** Read more divider. */
let readmoreHR = document.getElementById("readmore").content;

/** Icons for posts. */
let icons = {
	/** Question mark; used beside "speakers" i.e. usernames */
	question: document.getElementById("iconspeaker").content,
	/** Calendar */
	date: document.getElementById("icondate").content,
	/** Reblog arrows */
	reblog: document.getElementById("iconreblog").content,
	/** Heart (outline) */
	like: document.getElementById("iconlike").content,
	/** Heart (solid) */
	liked: document.getElementById("iconliked").content,
	/** Chain links */
	link: document.getElementById("iconlink").content,
	/** Push pin */
	pin: document.getElementById("iconpin").content,
	/** Hashtag */
	tag: document.getElementById("icontag").content,
};

/** The standard page font size, for calculating padding.
 * @type {number}
 */
const em = parseFloat(getComputedStyle(document.documentElement).fontSize);

/** For use with Tippy tooltips. Standard themeing for all tooltips. */
let tippyOptions = {
	// Basic layout
	theme: "beebo",
	placement: "bottom",
	arrow: false,
	duration: 0, // Don't fade in/out
};

// #region Lightbox setup
/** The lightbox dialog.
 * @type {HTMLElement}
 */
let lightbox = document.getElementById("lightbox");

/** All images from the trail item currently being represented in the lightbox. Null if no lightbox is active.
 * @type {?HTMLElement[]}
 */
lightbox._images = null;

/** The index in lightbox._images of the image currently being viewed in the lightbox. Null if no lightbox is active.
 * @type {?number}
 */
lightbox._index = null;

lightbox._addImage = (img, position, autofocus = false) => {
	if (img == null) return;
	let adjacents = {
		"left": "center",
		"center": "right",
		"right": "NA"
	};
	img.setAttribute("class", position);
	if (autofocus) img.setAttribute("autofocus", "true");
	lightbox.insertBefore(img, lightbox.querySelector(".".concat(adjacents[position])));
}

lightbox._removeImage = (img) => {
	if (img == null) return;
	img.removeAttribute("class");
	img.remove();
}

/** Creates and opens a lightbox using the images from the target image's trail item.
 * @param [HTMLImageElement] targetImage The image selected to be opened in the lightbox
 */
lightbox._open = (targetImage) => {
	// Clear anything previously in the lightbox
	lightbox.querySelectorAll("img").forEach(el => el.remove());

	// Fetch the lightbox-ready images in this body item and check which to display
	// To avoid cloning images more than once, have each block of content hold its own image set once cloned
	let contentBlock = targetImage.closest(".bodyitemcontent, .mediawrapper");
	let imagegroup = Array.from(contentBlock.querySelectorAll("img.lightboxable"));
	if (!contentBlock._imageGroup) {
		contentBlock._imageGroup = imagegroup.map(el => el.cloneNode());
		contentBlock._imageGroup.forEach(el => el.classList.remove("lightboxable"));
	}
	lightbox._images = contentBlock._imageGroup;
	lightbox._index = imagegroup.findIndex(el => el === targetImage);

	// Prep images
	lightbox._addImage(lightbox._images[lightbox._index - 1], "left");
	lightbox._addImage(lightbox._images[lightbox._index], "center", true);
	lightbox._addImage(lightbox._images[lightbox._index + 1], "right");

	// Lightbox ready, show content
	lightbox.showModal();
}

/** Moves through lightbox images in a given direction.
 * @param {"left"|"right"}	direction	The direction to move in.
 * @param {HTMLElement}		focusTarget	The element on which to focus after moving.
 * @param {?"arrow"}		eventType	"arrow" if the move was triggered by an arrow key press; null otherwise.
 */
lightbox._moveTo = (direction, focusTarget, eventType = null) => {
	switch (direction) {
		case "left":
			if (lightbox._index === 0) break;
			// Previous image exists
			lightbox._index -= 1;
			lightbox._removeImage(lightbox.querySelector(".right"));
			lightbox.querySelector(".center")?.classList.replace("center", "right");
			lightbox.querySelector(".left")?.classList.replace("left", "center");
			lightbox._addImage(lightbox._images[lightbox._index - 1], "left");
			lightbox.querySelector(".".concat(focusTarget))?.focus();
			break;

		case "right":
			if (lightbox._index + 1 === lightbox._images.length) {
				if (eventType !== "arrow") lightbox._close();
				break;
			}
			// Next image exists
			lightbox._index += 1;
			lightbox._removeImage(lightbox.querySelector(".left"));
			lightbox.querySelector(".center")?.classList.replace("center", "left");
			lightbox.querySelector(".right")?.classList.replace("right", "center");
			lightbox._addImage(lightbox._images[lightbox._index + 1], "right");
			lightbox.querySelector(".".concat(focusTarget))?.focus();
			break;

		default:
			break;
	}
}

/** Closes the lightbox and resets internal counters. */
lightbox._close = () => {
	lightbox.close();
	// Remove the images in the lightbox
	lightbox.querySelectorAll("img").forEach(el => el.remove());
	// Reset the internal lightbox counters
	lightbox._images = null;
	lightbox._index = null;
}

// Set up click events for image navigation
lightbox.addEventListener("click", e => {
	switch (e.target.className) {
		case "left":
			lightbox._moveTo("left", "left");
			break;

		case "center":
			lightbox._moveTo("right", "center");
			break;

		case "right":
			lightbox._moveTo("right", "right");
			break;

		// Don't add event handler for the close button; that's already taken care of

		default:
			break;
	}
});
// Set up keyboard events for image navigation
lightbox.addEventListener("keydown", e => {
	let currFocus = document.activeElement.className;
	if (e.key === "ArrowLeft") {
		lightbox._moveTo("left", currFocus, "arrow");
		return;
	}
	else if (e.key === "ArrowRight") {
		lightbox._moveTo("right", currFocus, "arrow");
		return;
	}
	if (e.key !== "Enter" && e.key !== " ") return;
	e.preventDefault();
	switch (e.target.className) {
		case "left":
			lightbox._moveTo("left", currFocus);
			break;

		case "center":
			lightbox._moveTo("right", currFocus);
			break;

		case "right":
			lightbox._moveTo("right", currFocus);
			break;

		// Don't add event handler for the close button; that's already taken care of

		default:
			break;
	}
});
// #endregion
// #endregion



// #region POST CREATION
// #region Post array declaration
let posts = [
	/*{block:Posts}*/{
		npf: {NPF},

		/*{block:PermalinkPage}*/
		// For ask/submit/general blog pages
		/*{block:Title}*/ title: {JSTitle}, /*{/block:Title}*/
		body: {JSBody},
		/*{/block:PermalinkPage}*/

		/*{block:Date}*/
		// Post-specific items

		id: {JSPostID},
		permalink: {JSPermalink},

		date: {
			day: {JSDayOfWeek},
			textDM: "{DayOfMonth} {Month}, {Year}",
			numDM: "{DayOfMonth}/{MonthNumber}/{Year}",
			textMD: "{Month} {DayOfMonth}, {Year}",
			numMD: "{MonthNumber}/{DayOfMonth}/{Year}",
			textDMZ: "{DayOfMonthWithZero} {Month}, {Year}",
			numDMZ: "{DayOfMonthWithZero}/{MonthNumberWithZero}/{Year}",
			textMDZ: "{Month} {DayOfMonthWithZero}, {Year}",
			numMDZ: "{MonthNumberWithZero}/{DayOfMonthWithZero}/{Year}",
			time12: "{12Hour}:{Minutes} {CapitalAmPm}",
			time24: "{24Hour}:{Minutes}",
			time12Z: "{12HourWithZero}:{Minutes} {CapitalAmPm}",
			time24Z: "{24HourWithZero}:{Minutes}",
			url: "/day/{Year}/{MonthNumberWithZero}/{DayOfMonthWithZero}",
		},

		/*{block:PinnedPostLabel}*/ pinned: {JSPinnedPostLabel}, /*{/block:PinnedPostLabel}*/

		/*{block:HasTags}*/ tags: [
			{block:Tags} {
				name: {JSTag},
				url: {JSTagURL},
			}, {/block:Tags}
		], /*{/block:HasTags}*/

		/*{block:RebloggedFrom}*/
		via: {
			name: {JSReblogParentName},
			url: {JSReblogParentURL},
			avatar: {JSReblogParentPortraitURL-40},
			label: "{lang:Reblogged from ReblogParentName}",
			labellink: `{lang:Reblogged from ReblogParentName 2}`,
		},
		source: {
			name: {JSReblogRootName},
			url: {JSReblogRootURL},
			avatar: {JSReblogRootPortraitURL-40},
			label: "{lang:Originally from ReblogRootName}",
			labellink: `{lang:Originally from ReblogRootName 2}`,
		},
		/*{/block:RebloggedFrom}*/

		/*{block:NoteCount}*/
		noteCount: {JSNoteCount},
		noteCountWithLabel: {JSNoteCountWithLabel},
		postNotes: {JSPostNotesURL},
		/*{/block:NoteCount}*/

		like_html: {JSLikeButton size="30"},
		reblog_url: {JSReblogURL},

		/*{block:Submission}*/ submission: {
			name: {JSSubmitter},
			url: {JSSubmitterURL},
			avatar: {JSSubmitterPortraitURL-128},
			label: "{lang:Submitted By}",
		}, /*{/block:Submission}*/

		/*{block:ContentSource}*/ contentSource: {
			name: {JSSourceTitle},
			url: {JSSourceURL},
			/*{block:SourceLogo}*/ logo: {
				url: {JSBlackLogoURL},
				width: {JSLogoWidth},
				height: {JSLogoHeight},
			}, /*{/block:SourceLogo}*/
		}, /*{/block:ContentSource}*/

		/*{/block:Date}*/
	},/*{/block:Posts}*/
	/*{block:NoPosts}*/{
		npf: {
			content: [
				{
					type: "text",
					text: "{lang:This Tumblr hasnt posted anything}"
				}
			],
			layout: [],
			trail: []
		}
	},/*{/block:NoPosts}*/
	/*{block:NoSearchResults}*/{
		npf: {
			content: [
				{
					type: "text",
					text: `{lang:Sorry no results for SearchQuery 2}.`
				}
			],
			layout: [],
			trail: []
		}
	},/*{/block:NoSearchResults}*/
];
// #endregion

/** The wrapper element in which all posts will be inserted */
let postContainer = document.getElementById("posts");

// #region The main post creation loop
posts.forEach((post, index) => {
	/** The HTML article corresponding to the post currently being created */
	let article = document.createElement("article");
	article.classList.add("post");
	postContainer.append(article);

	// Backup method, using the old "body" T-var
	if (
		(post.npf.content.length === 0 && post.npf.trail.length === 0)
		/*{block:AskPage}*/|| true/*{/block:AskPage}*/
		/*{block:SubmitPage}*/|| true/*{/block:SubmitPage}*/
	) {
		createPage(article, post);
		return;
	}
	// Regardless of NPF/.body creation, mark if currently on a custom blog page
	if (document.querySelector("#pages .current-page") != null)
		document.body.classList.add("page");

	// Content available via NPF
	// Create, but put guards in for header/footer just in case pages are parsed as NPF too

	// No header for this theme; put everything in footer

	/** The body of the post, to be populated with trail items */
	let postBody = document.createElement("section");
	postBody.classList.add("body");
	article.append(postBody);
	// Create each reblog of the post
	if (!post.npf.trail.length) { article.classList.add("original") }
	else { post.npf.trail.forEach(trailItem => createTrailItem(
		postBody,
		trailItem,
		null
		/*{block:PermalinkPage}*/, true/*{/block:PermalinkPage}*/
	)) }
	// End with the current blog's addition, if any
	if (post.npf.content.length) {
		createTrailItem(
			postBody,
			post.npf,
			post.id
			/*{block:PermalinkPage}*/, true/*{/block:PermalinkPage}*/
		);
	}
	// In the above, expand any read more links if on the permalink page

	if (post.id !== undefined)
		createPostFooter(article, post);

	/*{block:IfFilteredTags}*/
	if (post.tags) {
		// User has provided tags to filter. Check each post's tags and add a filter message
		let filters = post.tags.filter(tag => filteredTags.includes(tag.name.toLowerCase()));
		if (filters.length > 0) {
			// Hide post content
			article.classList.add("filtered");

			// Assemble and insert filter message
			let msg = filterMessage.cloneNode(true);
			msg.querySelector(".tags").textContent = "#".concat(filters.map(el => el.name).join(", #"));
			msg.querySelector("button").addEventListener("click", (e) => {
				e.currentTarget.closest(".filter").remove();
				article.classList.remove("filtered");
			});
			article.insertBefore(msg, article.firstElementChild);
		}
	}
	/*{/block:IfFilteredTags}*/

	if (index !== posts.length - 1) postContainer.append(postSeparator.cloneNode(true));
});
// #endregion

// #region Remaining post functionality
// Add lightboxes to all applicable images
document.querySelectorAll("img.lightboxable").forEach(obj => {
	obj.setAttribute("tabindex", "0");
	obj.addEventListener("click", e => { lightbox._open(e.currentTarget) });
	obj.addEventListener("keydown", e => {
		if (e.key === "Enter" || e.key === " ") { lightbox._open(e.currentTarget) }
	});
});

/*{block:PermalinkPage}*/
// Add post notes on permalink pages
if (posts.at(0)?.postNotes) {
	document.body.classList.add("hasnotes")
	createNotes(posts[0].postNotes);
}
/*{/block:PermalinkPage}*/
// #endregion

// #region Remaining page functionality (base features)
document.getElementById("opennotepad")?.addEventListener("click", () => document.getElementById("notepad")?.showModal());
// Since description might be absent, force the first tab to be selected
document.querySelector("#notepad input:first-of-type")?.setAttribute("checked", "checked");	// Null-safe for Tumblr preview

// #region Dialog closure
// Set up closure on button click
document.querySelectorAll("dialog .closebtn").forEach(btn => {
	const dialog = btn.closest("dialog");
	btn.addEventListener("click", (e) => (
		dialog._close ? dialog._close() : dialog.close()
	));
	btn.addEventListener("keydown", (e) => e.key === "Enter" || e.key === " " ? (
		dialog._close ? dialog._close() : dialog.close()
	) : null);
})
// Set up closure on ::backdrop click
document.querySelectorAll("dialog").forEach(dialog => {
	dialog.addEventListener("mousedown", e => {
		e.currentTarget._offsetX = e.offsetX;
		e.currentTarget._offsetY = e.offsetY;
	});
	dialog.addEventListener("click", e => {
		if ((
			e.currentTarget._offsetX < 0 || e.currentTarget._offsetX > e.target.offsetWidth ||
			e.currentTarget._offsetY < 0 || e.currentTarget._offsetY > e.target.offsetHeight
		) && (
			e.offsetX < 0 || e.offsetX > e.target.offsetWidth ||
			e.offsetY < 0 || e.offsetY > e.target.offsetHeight
		) && (
			// If this is the notepad, make sure you're not switching tabs
			dialog.id === "notepad" ? !e.target.closest("#notepadtabs") : true
		)) {
			dialog._close ? dialog._close() : dialog.close();
		}
	});
});
// #endregion
// #endregion

// #region Remaining page functionality (accessibility features)
// Keyboard navigation moved to very end, after the "Visual extras" region, in order to prevent errors being thrown in Customize preview window.

// #region Scroll to top
(scrolltotop = document.getElementById("scrolltotop")).addEventListener("click", () => {
	window.scrollTo({
		top: 0,
		behavior: "smooth",
	});
});
document.addEventListener("scroll", () => {
	if (window.pageYOffset <= 100) {
		scrolltotop.setAttribute("disabled", "true");
	}
	else {
		scrolltotop.removeAttribute("disabled");
	}
})
// #endregion
// #endregion

// #region Visual extras
// #region Set up tooltips
// Pagination
tippy.createSingleton(tippy("#pagination [data-tippy-content]"), tippyOptions);
// Post icons
tippy.createSingleton(tippy(".post [data-tippy-content]"), tippyOptions);
// Prepare variables for notes section's tooltips
var notesTooltipInstances, notesTooltips;
// #endregion
// #endregion

// Set up keyboard navigation
keyboardNav({
	postOffset: 3 * em,	// Don't stick to top of page
});
// #endregion



// #region CONSTRUCTOR FUNCTIONS

// #region FOR POST HEADER/FOOTER
/** Creates a post footer object and appends it to the given post object.
 * The individual elements in the footer can be rearranged as per theme preference.
 * @param {HTMLElement} wrapper The HTML object for this post, to which the footer will be added.
 * @param {Object} postData This post's data, containing relevant information to populate the footer with.
 */
function createPostFooter(wrapper, postData) {
	let footer = document.createElement("footer");
	wrapper.append(footer);

	let topBar = document.createElement("p");
	topBar.classList.add("top", "bar");
	footer.append(topBar);

	let topLeft = document.createElement("span");
	topLeft.classList.add("left");
	let topRight = document.createElement("span");
	topRight.classList.add("right");

	// Date
	/*{block:IfPostDates}*/
	makeDate(topLeft, postData, {
		/*{block:IfDatesFormattedMonthFirst}*/dateFormat: "textMD",/*{/block:IfDatesFormattedMonthFirst}*/
		/*{block:IfPostTimes}*/includeTime: true,/*{/block:IfPostTimes}*/
		/*{block:If24HourTimes}*/timeFormat: "24",/*{/block:If24HourTimes}*/
	});
	/*{/block:IfPostDates}*/

	// Notes
	makeNoteCount(topLeft, postData, true);

	// Icons
	makePin(topRight, postData);

	makeViaSource(topRight, postData, true);

	/*{block:IfNotPostDates}*/makePermalink(topRight, postData);/*{/block:IfNotPostDates}*/
	/*{block:IfDayPageLinks}*/makeDayLink(topRight, postData);/*{/block:IfDayPageLinks}*/
	/*{block:IfPostTags}*/
	/*{block:IfShowTagsOnClick}*/makeTagToggle(topRight, /*{/block:IfShowTagsOnClick}*/
		makeTags(footer, postData, { hashtags: false })
	/*{block:IfShowTagsOnClick}*/);/*{/block:IfShowTagsOnClick}*/
	/*{/block:IfPostTags}*/
	/*{block:IfReblogButtons}*/makeReblog(topRight, postData);/*{/block:IfReblogButtons}*/
	/*{block:IfLikeButtons}*/makeLike(topRight, postData);/*{/block:IfLikeButtons}*/

	// Mark non-empty
	if (topLeft.childElementCount) topBar.append(topLeft);
	if (topRight.childElementCount) topBar.append(topRight);

	// Content source and "submitted by" label
	if (postData.contentSource || postData.submission) {
		let bottomBar = document.createElement("p");
		bottomBar.classList.add("bottom", "bar");
		footer.append(bottomBar);

		makeContentSource(bottomBar, postData);
		makeSubmitter(bottomBar, postData);
	}
}

// #region Helpers
/** Creates a like button for a given post.
 * @param {HTMLElement} wrapper The child element of the post to which the like button will be added. Usually the footer.
 * @param {Object} postData This post's data, containing relevant information to create the like button with.
 */
function makeLike(wrapper, postData) {
	// Make element
	let likeButton = document.createElement("a");
	likeButton.classList.add("customlike");
	likeButton.innerHTML = postData.like_html;
	wrapper.append(likeButton);

	// Icons
	likeButton.append(icons.like.cloneNode(true), icons.liked.cloneNode(true));

	// Label
	likeButton.firstElementChild.setAttribute("data-tippy-content", `{block:English}Like{/block:English}{block:German}Liken{/block:German}{block:French}J'aime{/block:French}{block:Italian}Mi piace{/block:Italian}{block:Japanese}スキ{/block:Japanese}{block:Turkish}Beğen{/block:Turkish}{block:Spanish}Me gusta{/block:Spanish}{block:Russian}Нравится{/block:Russian}{block:Polish}Lubię{/block:Polish}{block:PortuguesePT}Gostar{/block:PortuguesePT}{block:PortugueseBR}Curtir{/block:PortugueseBR}{block:Dutch}Vind ik leuk{/block:Dutch}{block:Korean}좋아요{/block:Korean}{block:ChineseSimplified}喜欢{/block:ChineseSimplified}{block:ChineseTraditional}喜歡{/block:ChineseTraditional}{block:ChineseHK}喜歡{/block:ChineseHK}{block:Indonesian}Suka{/block:Indonesian}{block:Hindi}पसंद करें{/block:Hindi}`);
}

/** Creates a reblog button for a given post.
 * @param {HTMLElement} wrapper The child element of the post to which the reblog button will be added. Usually the footer.
 * @param {Object} postData This post's data, containing relevant information to create the reblog button with.
 */
function makeReblog(wrapper, postData) {
	// Make element
	let reblogButton = document.createElement("a");
	reblogButton.href = postData.reblog_url;
	reblogButton.classList.add("customreblog");
	wrapper.append(reblogButton);

	// Icon and text
	reblogButton.setAttribute("data-tippy-content", "{block:English}Reblog{/block:English}{block:German}Rebloggen{/block:German}{block:French}Rebloguer{/block:French}{block:Italian}Reblogga{/block:Italian}{block:Japanese}リブログ{/block:Japanese}{block:Turkish}Yeniden Blogla{/block:Turkish}{block:Spanish}Rebloguear{/block:Spanish}{block:Russian}Реблог{/block:Russian}{block:Polish}Rebloguj{/block:Polish}{block:PortuguesePT}Reblogar{/block:PortuguesePT}{block:PortugueseBR}Reblogar{/block:PortugueseBR}{block:Dutch}Rebloggen{/block:Dutch}{block:Korean}리블로그{/block:Korean}{block:ChineseSimplified}转发{/block:ChineseSimplified}{block:ChineseTraditional}轉格{/block:ChineseTraditional}{block:ChineseHK}轉載{/block:ChineseHK}{block:Indonesian}Reblog{/block:Indonesian}{block:Hindi}रीब्लॉग करें{/block:Hindi}");
	reblogButton.prepend(icons.reblog.cloneNode(true));
}

/** Creates a link to the corresponding day page for a given post.
 * @param {HTMLElement} wrapper The child element of the post to which the day page link will be added. Usually the footer.
 * @param {Object} postData This post's data, containing relevant information to create the day page link with.
 */
function makeDayLink(wrapper, postData) {
	// Make element
	let dayLink = document.createElement("a");
	dayLink.href = postData.date.url;
	dayLink.classList.add("customday");
	wrapper.append(dayLink);

	// Icon and text
	dayLink.setAttribute("data-tippy-content", "{lang:Show all posts made on this day}");
	dayLink.prepend(icons.date.cloneNode(true));
}

/** Creates a button that toggles the visibility of the post's tags.
 * @param {HTMLElement} wrapper The child element of the post to which the tag toggle will be added. Usually the footer.
 * @param {HTMLElement} tagContainer The element containing the tags, on which to toggle the hide/show class.
 */
function makeTagToggle(wrapper, tagContainer) {
	if (!tagContainer) return;

	// Make element
	let tagToggle = document.createElement("button");
	tagToggle.classList.add("tagtoggle", "hidden");
	wrapper.append(tagToggle);

	// Functionality
	tagToggle.addEventListener("click", e => {
		e.currentTarget.classList.toggle("hidden");
		tagContainer.toggleAttribute("hidden");
	});

	// Icon and text
	tagToggle.append(icons.tag.cloneNode(true));
	tagToggle.setAttribute("data-tippy-content", "{lang:Tags}");
}

/** Creates a label indicating that a given post is a pinned post.
 * @param {HTMLElement} wrapper The child element of the post to which the pinned marker will be added. Usually the header.
 * @param {Object} postData This post's data, containing relevant information to create the pinned marker with.
 */
function makePin(wrapper, postData) {
	if (!postData.pinned) { return; }
	// Make element
	let pin = document.createElement("span");
	pin.id = "pinnedpost";
	wrapper.append(pin);
	// Icon and text
	pin.append(icons.pin.cloneNode(true));
	pin.setAttribute("data-tippy-content", postData.pinned);
}

/** Creates links to the blogs that a given post was reblogged from (via) and originally made by (source).
 * @param {HTMLElement} wrapper The child element of the post to which the via/source links will be added. Usually the footer.
 * @param {Object} postData This post's data, containing relevant information to create the via/source links with.
 * @param {boolean} [avatars=false] True if the links should consist of the users' avatars, or false if text labels should be used.
 */
function makeViaSource(wrapper, postData, avatars = false) {
	if (!postData.via) { return; }
	// Via and source links
	let via = document.createElement("a"),
		source = document.createElement("a");
	via.classList.add("viasource");
	source.classList.add("viasource");

	// Add via
	via.href = postData.via.url;
	via.setAttribute("data-tippy-content", postData.via.label);
	wrapper.append(via);

	// Check if source blog/post still exists
	let sourceTrail = postData.npf.trail[0];
	if (sourceTrail?.blog) {
		source.href = sourceTrail.blog.url.concat(sourceTrail.blog.url.endsWith("/") ? `post/${sourceTrail.post.id}` : `/${sourceTrail.post.id}`);
		source.setAttribute("data-tippy-content", postData.source.label);
		wrapper.append(source);
	}
	else if (postData.source.url !== "") {
		source.href = postData.source.url;
		source.setAttribute("data-tippy-content", postData.source.label);
		wrapper.append(source);
	}

	// Avatars or text, as needed
	if (avatars) {
		via.innerHTML = `<img class="avatar" />`;
		safeSetAvatar(via.firstElementChild, postData.via.avatar);
		source.innerHTML = `<img class="avatar" />`;
		safeSetAvatar(source.firstElementChild, postData.source.avatar);
	}
	else {
		via.innerText = "{lang:Via}";
		source.innerText = "{lang:Source}";
	}
}

/** Creates a label for the number of notes on a given post.
 * @param {HTMLElement} wrapper The child element of the post to which the note count will be added. Usually the footer.
 * @param {Object} postData This post's data, containing relevant information to create the note count with.
 * @param {boolean} [includeLabel=false] `true` to include the text label (e.g. "12 notes" instead of "12").
 */
function makeNoteCount(wrapper, postData, includeLabel = false) {
	if (!postData.noteCount) { return; }
	let notes = document.createElement("a");
	notes.href = postData.permalink.concat("#notes");
	notes.classList.add("notecount");
	notes.innerText = includeLabel ? postData.noteCountWithLabel : postData.noteCount;
	wrapper.append(notes);
}

/** Creates links to the tags a given post was tagged with.
 * @param {HTMLElement} wrapper The child element of the post to which the tags will be added. Usually the footer.
 * @param {Object} postData This post's data, containing relevant information to create the tag links with.
 * @param {Object} [tagOptions={}] Options for how to display the tags.
 * @param {boolean} [tagOptions.span=false] True if the tags should be contained in a <span> element. False if the container should be a <p> element.
 * @param {boolean} [tagOptions.commas=false] True if the tags should be separated by commas, false otherwise.
 * @param {boolean} [tagOptions.hashtags=true] True if the tags should be prefixed by hashtags, false otherwise.
 */
function makeTags(wrapper, postData, tagOptions = {}) {
	if (!postData.tags) { return; }
	let options = Object.assign({
		span: false,
		commas: false,
		hashtags: true,
	}, tagOptions);
	// Make element
	let tags = document.createElement(options.span ? "span" : "p");
	tags.classList.add("tags");
	/*{block:IfShowTagsOnClick}*/tags.setAttribute("hidden", "hidden");/*{/block:IfShowTagsOnClick}*/
	// Populate with each tag
	postData.tags.forEach((tag, arr, index) => {
		let a = document.createElement("a");
		a.href = tag.url;
		a.innerHTML = (options.hashtags ? "#" : "").concat(unescapeHTML(tag.name));
		tags.append(a);
		if (options.commas && index < arr.length - 1) tags.append(", ");
	});
	wrapper.append(tags);
	return tags;
}

/** Creates a date label showing when a given post was posted/reblogged.
 * @param {HTMLElement} wrapper The child element of the post to which the date label will be added. Usually the header.
 * @param {Object} postData This post's data, containing relevant information to create the date label with.
 * @param {Object} [dateOptions={}] Options for the formatting of the date.
 * @param {boolean} [dateOptions.includeDay=false] True if the weekday should be included in the date label, false otherwise.
 * @param {string} [dateOptions.dateFormat="textDM"] The format of the date, month, and year portion of the label. Either "text" or "num" (numerical) for the month name, "DM" or "MD" for the date-month ordering, followed by an optional "Z" if dates and months should be zero-padded.
 * @param {boolean} [dateOptions.includeTime=false] True if the time of reblogging/posting should be included in the date label, false otherwise.
 * @param {string} [dateOptions.timeFormat="12"] The format of the time portion of the label. Either "12" or "24" for 12-hour (AM/PM) or 24-hour format, followed by an optional "Z" if hours should be zero-padded.
 * @param {boolean} [dateOptions.commaSeparate=true] For when includeTime is set to true. True if the label should be formatted as "[DATE], [TIME]", and false if the label should be formatted as "[DATE] at [TIME]".
 */
function makeDate(wrapper, postData, dateOptions = {}) {
	let options = Object.assign({
		includeDay: false,
		dateFormat: "textDM",
		includeTime: false,
		timeFormat: "12",
		commaSeparate: true,
	}, dateOptions),
		date = document.createElement("a");
	// Make element
	date.href = postData.permalink;
	date.classList.add("date");
	wrapper.append(date);
	// Add day, as needed
	if (options.includeDay) {
		date.innerText = postData.date.day.concat(", ");
	};
	// Add date
	date.innerText += postData.date[options.dateFormat];
	// Add time, as needed
	if (options.includeTime) {
		date.innerText += (options.commaSeparate ? ", " : " at ").concat(postData.date[`time${options.timeFormat}`]);
	}
}

/** Creates a permalink for a given post, without any date.
 * @param {HTMLElement} wrapper The child element of the post to which the permalink will be added. Usually the header.
 * @param {Object} postData This post's data, containing relevant information to create the permalink with.
 */
function makePermalink(wrapper, postData) {
	let link = document.createElement("a");
	link.href = postData.permalink;
	link.classList.add("permalink");
	wrapper.append(link);
	// Icon and text
	link.append(icons.link.cloneNode(true));
	link.setAttribute("data-tippy-content", "{lang:Permalink}");
}

/** Creates a label indicating a given post is a submission.
 * @param {HTMLElement} wrapper The child element of the post to which the submission label will be added. Usually the header.
 * @param {Object} postData This post's data, containing relevant information to create the submission label with.
 * @param {boolean} [label=true] True if a text label should be included giving the submitter's name, potentially with a link to their blog
 * @param {boolean} [avatar=false] True if the submitter's avatar should be included.
 */
function makeSubmitter(wrapper, postData, label = true, avatar = false) {
	if (!(subData = postData.submission)) { return; }
	let sublabel = document.createElement("span");
	sublabel.classList.add("sublabel");
	wrapper.append(sublabel);
	// Include avatar?
	if (avatar) { sublabel.innerHTML = `<img src="${subData.avatar}" />` }
	// Submitter name, with link to blog if provided
	// (only if labels are requested!)
	if (label) {
		if (subData.url.length) {
			sublabel.innerHTML += subData.label.replace(subData.name, `<a href="${subData.url}">${subData.name}</a>`);
		}
		else {
			sublabel.innerHTML += subData.label.replace(subData.name, `<a>${subData.name}</a>`);
		}
	}
	else {
		sublabel.setAttribute("data-tippy-attribute", subData.label);
	}
}

/** Creates a label indicating the source of a given post's content.
 * @param {HTMLElement} wrapper The child element of the post to which the content source label will be added. Usually the header.
 * @param {Object} postData This post's data, containing relevant information to create the content source with.
 * @param {boolean} [label=true] True if a "Source:" prefix should be included before the link to the source, false otherwise
 * @param {boolean} [logo=false] True if any provided logos should be displayed on the link instead of the source's text name, false otherwise
 */
function makeContentSource(wrapper, postData, label = true, logo = false) {
	if (!(sourceData = postData.contentSource)) { return; }
	let source = document.createElement("span");
	source.classList.add("source");
	wrapper.append(source);
	// Include label?
	if (label) { source.innerText = "{lang:Source}: " }
	// Display as...
	if (logo && sourceData.logo) {
		// Image, no text
		source.innerHTML += `<a href="${sourceData.url}"><img src="${sourceData.logo.url}" width="${sourceData.logo.width}" height="${sourceData.logo.height}" alt="${sourceData.name}" /></a>`;
	}
	else {
		// Text, no image
		source.innerHTML += `<a href="${sourceData.url}">${sourceData.name}</a>`;
	}
}

/** Maps an NPF post object to the corresponding legacy post type. Evaluates only original trail items, in the following order:
 * Answer > Video > Photo > Audio > Quote > Chat > Link > Text
 * @param {Object} npf A post's NPF object.
 * @param {Object[]} npf.trail The trail items, if this post was reblogged. When non-empty, the first of these trail items has its "content" property evaluated to determine the post type.
 * @param {Object[]} npf.content The current blog's contribution to this post. For original posts, this property is evaluated to determine the post type.
 * @param {Object[]} [npf.layout] Checked on original posts to determine if this is an answer post. On reblogged posts, the first trail item may contain a similar property.
 */
function getPostType(npf) {
	// takes post npf object and checks first trail item to determine post type
	let trailItem = npf.trail[0] ? npf.trail[0] : npf;

	if (trailItem.layout?.some(el => el.type === "ask")) { return "answer" }
	else if (trailItem.content.some(el => el.type === "video")) { return "video" }
	else if (trailItem.content.some(el => el.type === "image")) { return "photo" }
	else if (trailItem.content.some(el => el.type === "audio")) { return "audio" }
	else if (trailItem.content.some(el => el.type === "audio" && el.subtype === "quote")) { return "quote" }
	else if (trailItem.content.filter(el => el.type === "chat").length > 1) { return "chat" }
	else if (trailItem.content.some(el => el.type === "link")) { return "link" }
	else { return "text" }
}
// #endregion
// #endregion

// #region FOR POST BODY
/** Creates a trail item in the body of a post, containing a single blog's contribution to that post.
 * @param {HTMLElement} post The wrapper into which to insert the complete trail item, usually a post body element.
 * @param {Object} npf The NPF object containing information about this trail item.
 * @param {string} postID The ID of this specific iteration of the post, as seen in the URL.
 * @param {boolean} [expand=false] True if any "read more" dividers in a post should be skipped and the full post rendered; false if the "read more" should be rendered and subsequent content hidden.
 */
function createTrailItem(post, npf, postID, expand = false) {
	let item = document.createElement("div");
	item.classList.add("bodyitem");
	post.append(item);

	// extant blog; create directly
	if (npf.blog !== undefined) { createTrailItemHeader(item, npf.blog, npf.post) }

	// deleted/unrecoverable blog; provide the anon avatar
	else if (npf.broken_blog_name !== undefined) {
		createTrailItemHeader(item, {
			 name: npf.broken_blog_name,
			 avatar: anonAvatar,
		});
	}

	// blog is currentUser; provide directly-pulled info
	else { createTrailItemHeader(item, currentUser, { id: postID }) }

	// create the body of their contribution
	createTrailItemBody(item, npf, { id: postID }, expand);
}


/** Creates the header for a specific trail item, rendering the blog that authored this trail item. Includes links to the versions of the post on the contributing blogs, where available.
 * @param {HTMLElement} trailItem The trail item wrapper into which to insert the header.
 * @param {Object} blogData Information about the user that authored this trail item.
 * @param {Object} [postData=null] Information about this iteration of the post; null if the blog that authored this iteration is deactivated/broken or if the post is otherwise unavailable.
 */
function createTrailItemHeader(trailItem, blogData, postData = null) {
	let header = document.createElement("header");
	header.classList.add("user");
	trailItem.append(header);
	let link = document.createElement("a");
	link.classList.add("usertext");

	// mark broken trail items
	if (postData === null || blogData.active === false) { header.classList.add("deactivated") }

	// add link where original posts exist, with safeguards for pages
	if (postData?.id === undefined && blogData.active != null) {
		// page! link back to itself
		link.href = window.location.href;
	}
	else if (blogData.url && blogData.active) {
		link.href = blogData.url.concat(blogData.url.endsWith("/") ? `post/${postData.id}` : `/${postData.id}`);
	}

	// Get the username and avatar
	let username = document.createElement("span");
	username.classList.add("name");
	username.innerHTML = blogData.name;
	// Generally an active user's nested size-128 URL (index 1 of [512,128,96,64]), or a direct URL for currentUser or anon/broken users
	// The array blog.avatar isn't available sometimes, so include a backup avatar fetch via API
	let avatar = document.createElement("img");
	avatar.classList.add("avatar");
	safeSetAvatar(
		avatar,
		blogData.avatar
		? typeof(blogData.avatar) === "object"
			? blogData.avatar?.find(el => el.height === 128)?.url
			: blogData.avatar
		: `https://api.tumblr.com/v2/blog/${blogData.name ?? ""}/avatar/128`,
	);

	// put together the header
	link.append(icons.question.cloneNode(true), username)
	header.append(link, avatar);
}


/** Renders the body of each individual trail item.
 * @param {HTMLElement} trailItem The trail item wrapper into which to insert the body.
 * @param {Object} npf The NPF object containing information about this trail item.
 * @param {string} postID The ID of this specific iteration of the post, as seen in the URL.
 * @param {boolean} expand True if any "read more" dividers in a post should be skipped and the full post rendered; false if the "read more" should be rendered and subsequent content hidden.
 */
function createTrailItemBody(trailItem, npf, postData, expand) {
	let content = npf.content;
	let rows = npf.layout.find(l => l.type === "rows");
	let body = document.createElement("div");
	let args = [
		// For poll content blocks, a link to the in-dashboard view
		npf.blog !== undefined ? npf.blog.blog_view_url.concat("/", npf.post.id)
			: npf.broken_blog_name === undefined ? `https://tumblr.com/${currentUser.name}/${postData.id}`
			: "",
		// For paywall content blocks, the paywaller's info and the post object for the viewer's subscription status
		npf.blog ?? currentUser,
		npf.post,
	];
	body.classList.add("bodyitemcontent");
	trailItem.append(body);

	// Rather than make the blocks and *then* rearranging them into order,
	// Make the blocks in order to begin with
	if (rows) { // Some order present; make them in order
		for (let i = 0; i < rows.display.length; i++) {
			const row = rows.display[i];

			// Render the row, depending on the number of blocks it contains
			if (row.blocks.length > 1) {
				// First make the blocks
				let allBlocks = row.blocks.map(index => createContentBlock(body, content, index, ...args));

				// Get the row containing the first element
				// (creating said row if need be)
				let currRow = allBlocks[0];
				if (!currRow.classList.contains("row")) {
					// Create a new row
					let newRow = document.createElement("div");
					newRow.classList.add("row", "NEWLYMADE");
					body.append(newRow);
					// Put the row's first element inside it
					newRow.append(currRow);
					// And update what we're considering the first row
					currRow = newRow;
				}

				// Add the rest of the elements
				allBlocks.forEach((el, i) => {
					if (i === 0) return;

					if (el.classList.contains("row")) {
						currRow.append(el.firstElementChild);
						el.remove();
					}
					else {
						currRow.append(el);
						el.setAttribute("data-index", row.blocks[i]);
						// For images, make the image itself lightbox-capable
						if (el.tagName === "FIGURE") el.firstElementChild.classList.add("lightboxable");
					}
				});
			}
			else {
				// figure out the content type and create the block based on that
				createContentBlock(body, content, row.blocks[0], ...args);
			}

			// And finally, check if the post truncates after this row
			if (row.blocks.includes(rows.truncate_after) && expand)	// Readmore that should be expanded
				body.append(readmoreHR.cloneNode(true));
			else if (row.blocks.includes(rows.truncate_after)) {	// Readmore that shouldn't be expanded
				let readmore = document.createElement("button");
				readmore.classList.add("readmore");
				readmore.innerText = "{lang:Read more}";
				readmore.addEventListener("click", e => {
					e.currentTarget.closest(".post").querySelectorAll(".readmore").forEach(el => el.replaceWith(readmoreHR.cloneNode(true)));
				});
				body.append(readmore);

				// Render the rest of the blocks, they just won't be shown via CSS
			}
		}
	}
	// No defined order; make them in index order
	// No `rows` also means no readmore!
	else content.forEach((block, i) => createContentBlock(body, content, i, ...args));

	// If there's an ask, separate it from its answer, if any
	let askNPF = npf.layout.find(l => l.type === "ask");
	if (askNPF) {
		// Anon or not?
		let asker = document.createElement("header");
		asker.classList.add("user");
		let askerLink = document.createElement("a"),
			askerIcon = document.createElement("img"),
			askerName = document.createElement("span"),
			askingLabel = document.createElement("span");

		// Classes
		askerLink.classList.add("usertext");
		askerIcon.classList.add("avatar");
		askerName.classList.add("name");
		// Question icon
		if (askNPF.attribution) {
			// Set avatar
			safeSetAvatar(askerIcon, askNPF.attribution.blog.avatar?.find(el => el.height === 128)?.url ?? `https://api.tumblr.com/v2/blog/${askNPF.attribution.blog.name ?? ""}/avatar/128`);
			// Set link
			askerLink.href = askNPF.attribution.blog.url;
			// Set username
			askerName.innerText = askNPF.attribution.blog.name;
		}
		else {
			// Set avatar
			askerIcon.src = anonAvatar;
			// Set username
			askerName.innerText = "Anonymous";
		}
		askingLabel.textContent = " asked:";
		askerLink.append(icons.question.cloneNode(true), askerName, askingLabel);
		asker.append(askerLink, askerIcon);

		let ask = document.createElement("div");
		ask.classList.add("bodyitem", "ask");
		ask.append(asker);
		let askBody = document.createElement("div");
		askBody.classList.add("bodyitemcontent");
		ask.append(askBody);

		if (rows) {
			// Find where the last row containing a block included in the ask is
			// That (plus one for zero-indexing) is the number of rows that should be in the ask
			let i = rows.display.findLastIndex(row => askNPF.blocks.some(blockIndex => row.blocks.includes(blockIndex))) + 1;

			while (i > 0) {
				i --;
				askBody.append(body.children[0]);
			}
		}
		// just a simple stack. take the specified blocks and put them in the ask
		else askNPF.blocks.forEach(() => askBody.append(body.children[0]));

		// Place in root post body, above answer trail item
		trailItem.parentElement.insertBefore(ask, trailItem);

		// Sometimes asks have no answer content (i.e. nothing left in body); in this case, clean up answerer section
		if (body.childElementCount === 0) trailItem.remove();
	}
}


/** Renders a single content block in the body of a trail item.
 * @param {HTMLElement} trailItem The trail item body wrapper into which to insert this content block.
 * @param {Object} content The NPF content for the entire trail item, to assist in rendering certain content block types in relation to others in the trail item.
 * @param {number} i The index of this content block in the "content" object, i.e. this block's position in relation to other blocks.
 * @param {string} [blogViewLink=""] The URL to this post in the in-dashboard view, i.e. a link formatted in the style "https://tumblr.com/username/1234567890".
 * @returns The newly-created block.
 */
function createContentBlock(trailItem, content, i, blogViewLink = "", blogObj = {}, postObj = {}) {
	let curr = content[i];
	switch (curr.type) {

		case "text":
			bit = document.createElement(textSubtypes[curr.subtype] ?? "p");

			if (curr.subtype?.startsWith("heading")) bit.classList.add(curr.subtype);

			bit.innerHTML = formatText(curr);

			if (curr.subtype?.includes("ordered-list-item")) {
				// if first bullet point of a type, start a new list
				if (content[i - 1]?.subtype !== curr.subtype) {
					if (list) { trailItem.append(list); }
					list = document.createElement(curr.subtype === "ordered-list-item" ? "ol" : "ul")
				}

				list.append(bit); // continue the list

				// if last item in the list, or a last list, end the list and add the whole thing
				if (content[i + 1]?.subtype !== curr.subtype || i + 1 === content.length) {
					trailItem.append(list);
					list = null;
				}
			}
			else if ( ["quirky", "quote", "indented", "chat"].includes(curr.subtype) ) {
				bit.classList.add("npf_".concat(curr.subtype));
				trailItem.append(bit);
			}
			// otherwise it's a simple paragraph or blockquote or whatever. add
			else { trailItem.append(bit) }

			break;

		case "image":
			let breakpoint = 300;
			// assemble
			let row,
				fig = document.createElement("figure");
			bit = document.createElement("img");
			fig.append(bit);
			if (curr.media[0].width >= breakpoint) {
				// .row > figure.tmblr-full > img
				row = document.createElement("div");
				row.classList.add("row");
				fig.classList.add("tmblr-full");
				row.append(fig);
				trailItem.append(row);
				// Make large images lightbox-capable
				bit.classList.add("lightboxable");
			}
			// figure > img
			else trailItem.append(fig);

			// actual image
			bit.src = curr.media[0].url;
			bit.width = curr.media[0].width;
			bit.height = curr.media[0].height;
			// add alt text, if present
			if (curr.alt_text) { bit.setAttribute("alt", curr.alt_text) }
			// include colors, if present
			for (color in curr.colors) {
				bit.setAttribute("data-".concat(color), "#".concat(curr.colors[color]));
			}

			if (curr.caption) { // add caption, if present
				let caption = document.createElement("p");
				caption.innerText = curr.caption;
				fig.insertBefore(caption, bit.nextElementSibling);
			}

			if (curr.attribution) {
				let attrib = document.createElement("p");
				attrib.classList.add("tmblr-attribution");
				switch (curr.attribution.type) {
					case "post":
						attrib.innerHTML = `<a href="${curr.attribution.url}">{lang:Via} ${curr.attribution.blog.name}</a>`;
						break;
					case "link":
						attrib.innerHTML = `<a href="${curr.attribution.url}">{lang:Source}</a>`;
						break;
				}
				fig.insertBefore(attrib, bit.nextElementSibling);
			}

			// We're not appending bit itself, that's the image, so return the wrapper
			return row ?? fig;

		case "link":
			bit = document.createElement("div");
			bit.classList.add("npf-link-block");
			let link = document.createElement("a");
			let poster;
			if (curr.poster) {
				bit.classList.add("has-poster");
				poster = document.createElement("div");
				poster.classList.add("poster");
				poster.style.backgroundImage = `url(${curr.poster[0].url})`;
				link.append(poster);
			} else {
				bit.classList.add("no-poster");
			}
			if (curr.title) {
				let title = document.createElement("div");
				title.classList.add("title");
				title.innerText = curr.title;
				if (curr.poster) { poster.append(title) }
				else { link.append(title) }
			}
			let bottom = document.createElement("div");
			bottom.classList.add("bottom");
			if (curr.description) {
				let desc = document.createElement("div");
				desc.classList.add("description");
				desc.innerText = curr.description;
				bottom.append(desc);
			}
			// get "site name" - just the base url without the https
			let sitename = document.createElement("div");
			sitename.classList.add("site-name");
			// use display url if sitename is absent, as in older links
			sitename.innerText = curr.site_name ? curr.site_name : curr.display_url;
			bottom.append(sitename);

			link.append(bottom);
			link.href = curr.url;
			bit.append(link);
			trailItem.append(bit);
			break;

		case "audio":
			// Soundcloud links keep throwing 401 errors for some reason, so exclude
			if (curr.media && curr.provider !== "soundcloud") {
				// Display a custom player with more options
				bit = createCustomAudio(curr);
			}
			// TODO: else if client side SDK... need examples of metadata object
			// If embeds are present, use those
			else if (curr.embed_html) {
				bit = document.createElement("div");
				bit.innerHTML = curr.embed_html.trim();
				bit = bit.firstChild;
			}
			else if (curr.embed_url) {
				bit = document.createElement("iframe");
				bit.title = `Audio: ${curr.title ?? "Unknown title"} — ${curr.artist ?? "Unknown artist"}`;
				if (curr.album) { bit.title += ` (<em>${curr.album}</em>)` }
				bit.src = curr.embed_url;
				bit.width = "100%";
			}
			else {
				// All else failed; display a plain link to given URL
				bit = document.createElement("a");
				bit.href = curr.url;
				bit.innerText = `${curr.title ?? "Unknown title"} — ${curr.artist ?? "Unknown artist"}`;
				if (curr.album) { bit.innerHTML += `, <em>${curr.album}</em>` }
			}
			trailItem.append(bit);
			break;

		case "video":
			// Use media object to display default video player
			if (curr.media) {
				bit = document.createElement("video");
				bit.classList.add("video");
				bit.preload = "metadata";
				bit.controls = true;
				if (curr.poster) { bit.poster = curr.poster[0].url }
				bit.src = curr.media.url;
			}
			// TODO: else if client side SDK... need examples of metadata object
			// If embeds are present, use those
			else if (curr.embed_html) {
				bit = document.createElement("div");
				bit.innerHTML = curr.embed_html.trim();
				bit = bit.firstChild;
			}
			else if (curr.embed_url) {
				bit = document.createElement("iframe");
				bit.src = curr.embed_url;
				bit.width = "100%";
			}
			// All else failed; display a plain link to given URL
			else {
				bit = document.createElement("a");
				bit.href = curr.url;
				bit.innerText = curr.url;
			}
			trailItem.append(bit);
			break;

		case "paywall":
			bit = document.createElement("div");
			let title, label;
			bit.classList.add("paywall");
			bit.style.setProperty("--bg", blogObj.theme.background_color);
			bit.style.setProperty("--text", blogObj.theme.title_color);
			bit.style.setProperty("--accent", blogObj.theme.link_color);
			bit.style.setProperty("--font", blogObj.theme.title_font);

			if (postObj.paywall_access === "member") {
				// Shouldn't see this block at all! No need to render anything inside
				bit.style.setProperty("display", "none");
				trailItem.append(bit);
				break;
			}

			// Block should be visible. Format as appropriate
			switch (content[i].subtype) {
				case "cta":
					// For supportable blogs
					title = document.createElement("h2");
					label = document.createElement("p");
					supportlink = document.createElement("a");
					title.innerText = content[i].title;
					label.innerHTML = content[i].text.replace("%s", `<strong>${blogObj.name}</strong>`);
					supportlink.innerText = blogObj.subscription_plan?.checkout_labels?.support ?? "Show your Support";
					supportlink.href = content[i].url ?? `https://www.tumblr.com/${blogObj.name}/support`;
					bit.append(title, label, supportlink);
					break;

				case "divider":
					// For creators looking at own +Posts
					bit.classList.add("divider");
					bit.style.setProperty("--color", content[i].color);
					bit.innerText = content[i].text;
					break;

				case "disabled":
					// For blogs that have disabled Post+
					title = document.createElement("h2");
					label = document.createElement("p");
					title.innerText = content[i].title;
					label.innerHTML = content[i].text.replace("%s", `<strong>${blogObj.name}</strong>`);
					bit.append(title, label);
					break;
			}

			trailItem.append(bit);
			break;

		case "poll":
			bit = document.createElement("div");
			bit.classList.add("poll");
			trailItem.append(bit);

			// Create question, if present
			if (curr.question !== "") {
				let question = document.createElement("p");
				question.classList.add("question");
				question.innerText = curr.question;
				bit.append(question);
			}

			let expiryDate = new Date((curr.timestamp + curr.settings.expire_after) * 1000),
				timeToClosure = (expiryDate - (new Date())) / 1000,
				hasResults = (timeToClosure < 0) && blogViewLink.length;

			// Create answers
			let answer, answerText;
			/* If wanting poll icons...
			let pollIcons = {
					timeout: `<i class="ph ph-minus-square"></i>`,
					option: `<i class="ph ph-square"></i>`,
					optionChecked: `<i class="ph ph-check-square"></i>`,
				};
			*/
			curr.answers.forEach(a => {
				answer = document.createElement("a");
				answer.classList.add("option");
				if (blogViewLink.length) {
					answer.href = blogViewLink;
					answer.target = "_blank";
				}
				// Adding poll icons 
				// answer.innerHTML = hasResults ? pollIcons.timeout : pollIcons.option + pollIcons.optionChecked;
				answerText = document.createElement("p");
				answerText.innerText = a.answer_text;
				answer.append(answerText);
				bit.append(answer);
			});

			// See results link, if poll is expired
			// Timestamp/expiry durations are given in seconds; times 1000 for millisecond count
			let moreInfo = document.createElement(hasResults ? "a" : "span");
			bit.append(moreInfo);
			if (hasResults) {
				moreInfo.classList.add("results");
				moreInfo.href = blogViewLink;
				moreInfo.target = "_blank";
				moreInfo.rel = "noopener";
				moreInfo.innerText = "See Results";
				bit.classList.add("complete");
			}
			else {
				let timeLeft = {};
				timeLeft.days = Math.floor(timeToClosure / 86400);
				timeLeft.hours = Math.floor((timeToClosure - (timeLeft.days * 86400)) / 3600);
				timeLeft.minutes = Math.floor((timeToClosure - (timeLeft.days * 86400) - (timeLeft.hours * 3600)) / 60);
				let timeLabel = "Remaining time:";
				if (timeLeft.days > 0) {
					timeLabel += ` ${timeLeft.days} day${timeLeft.days === 1 ? "" : "s"}, ${timeLeft.hours} hour${timeLeft.hours === 1 ? "" : "s"}`;
				} else if (timeLeft.hours > 0) {
					timeLabel += ` ${timeLeft.hours} hour${timeLeft.hours === 1 ? "" : "s"}, ${timeLeft.minutes} minute${timeLeft.minutes === 1 ? "" : "s"}`;
				} else if (timeLeft.minutes > 0) {
					timeLabel += ` ${timeLeft.minutes} minute${timeLeft.minutes === 1 ? "" : "s"}`;
				} else {
					timeLabel += "less than 1 minute";	// guaranteed since poll hasn't calculated as closed yet
				}
				moreInfo.innerText = timeLabel;
				moreInfo.classList.add("timeleft");
			}
			break;

		default:
			bit = document.createElement("p");
			bit.innerHTML = `Error! This theme can't currently display ${curr.type} blocks :( Please contact <a href="https://starlightthemes.tumblr.com">the theme maker</a> to let them know about this issue.`;
			trailItem.append(bit);

	}
	return bit;
}

/** Helper function for createContentBlock, specifically for audio content blocks.
 * Renders an audio player in a custom style, with pause/play, skip to start/end, muting, and looping functionality.
 * @param {Object} npf The NPF object with links to and data on the audio file.
 * @param {Object} [defaultIcons={}] HTML strings representing the icons to use for the audio player.
 * @param {string} defaultIcons.play The icon to use as the "play" (⏵︎) button.
 * @param {string} defaultIcons.pause The icon to use as the "pause" (⏸︎) button.
 * @param {string} defaultIcons.toStart The icon to use as the "skip to start" (⏮︎) button.
 * @param {string} defaultIcons.toEnd The icon to use as the "skip to end" (⏭︎) button.
 * @param {string} defaultIcons.mute The icon to use as the "mute" (🔇) button.
 * @param {string} defaultIcons.unmute The icon to use as the "unmute" (🔊) button.
 * @param {string} defaultIcons.repeat The icon to use as the "loop" (🔁) button.
 * @param {string} defaultIcons.unrepeat The icon to use as the "stop looping" button.
 * @returns {HTMLElement} The complete audio element with attached event listeners.
 */
function createCustomAudio(npf, defaultIcons = {}) {
	// #region Basic blocks setup: icons, audio wrapper, and audio
	// Uses Phosphor icons by default
	// All icons need matching classes, except for skip to start/end
	let audicons = Object.assign({
		play: `<svg class="play" xmlns="http://www.w3.org/2000/svg" width="6" height="9" viewBox="0 0 6 9" preserveAspectRatio="xMidYMid meet" rendering="crispEdges" fill="currentColor" aria-hidden="true">
			<rect x="0" y="0" width="2" height="9" />
			<rect x="1" y="1" width="2" height="7" />
			<rect x="2" y="2" width="2" height="5" />
			<rect x="3" y="3" width="2" height="3" />
			<rect x="4" y="4" width="2" height="1" />
		</svg>`,
		pause: `<svg class="pause" xmlns="http://www.w3.org/2000/svg" width="6" height="9" viewBox="0 0 6 9" preserveAspectRatio="xMidYMid meet" rendering="crispEdges" fill="currentColor" aria-hidden="true">
			<rect x="0" y="0" width="2" height="9" />
			<rect y="0" width="2" height="9" x="4" />
		</svg>`,
		toStart: `<svg xmlns="http://www.w3.org/2000/svg" width="9" height="9" viewBox="0 0 9 9" preserveAspectRatio="xMidYMid meet" rendering="crispEdges" fill="currentColor" aria-hidden="true">
			<rect x="0" y="0" width="2" height="9" />
			<rect x="3" y="4" width="2" height="1" />
			<rect x="4" y="3" width="2" height="3" />
			<rect x="5" y="2" width="2" height="5" />
			<rect x="6" y="1" width="2" height="7" />
			<rect x="7" y="0" width="2" height="9" />
		</svg>`,
		toEnd: `<svg xmlns="http://www.w3.org/2000/svg" width="9" height="9" viewBox="0 0 9 9" preserveAspectRatio="xMidYMid meet" rendering="crispEdges" fill="currentColor" aria-hidden="true">
			<rect x="0" y="0" width="2" height="9" />
			<rect x="1" y="1" width="2" height="7" />
			<rect x="2" y="2" width="2" height="5" />
			<rect x="3" y="3" width="2" height="3" />
			<rect x="4" y="4" width="2" height="1" />
			<rect x="7" y="0" width="2" height="9" />
		</svg>`,
		mute: `<svg class="mute" xmlns="http://www.w3.org/2000/svg" width="9" height="9" viewBox="0 0 9 9" preserveAspectRatio="xMidYMid meet" rendering="crispEdges" fill="currentColor" aria-hidden="true">
			<rect x="0" y="3" width="3" height="3" />
			<rect x="2" y="2" width="2" height="5" />
			<rect x="3" y="1" width="2" height="7" />
			<rect x="4" y="0" width="1" height="9" />

			<rect x="6" y="3" width="1" height="3" />
			<rect x="8" y="1" width="1" height="7" />
		</svg>`,
		unmute: `<svg class="unmute" xmlns="http://www.w3.org/2000/svg" width="9" height="9" viewBox="0 0 9 9" preserveAspectRatio="xMidYMid meet" rendering="crispEdges" fill="currentColor" aria-hidden="true">
			<rect x="0" y="3" width="3" height="3" />
			<rect x="2" y="2" width="2" height="5" />
			<rect x="3" y="1" width="2" height="7" />
			<rect x="4" y="0" width="1" height="9" />

			<rect x="6" y="3" width="1" height="1" />
			<rect x="8" y="3" width="1" height="1" />
			<rect x="7" y="4" width="1" height="1" />
			<rect x="6" y="5" width="1" height="1" />
			<rect x="8" y="5" width="1" height="1" />
		</svg>`,
		repeat: `<svg class="repeat" xmlns="http://www.w3.org/2000/svg" width="11" height="11" viewBox="0 0 11 11" preserveAspectRatio="xMidYMid meet" rendering="crispEdges" fill="currentColor" aria-hidden="true">
			<rect x="0" y="3" width="1" height="5" />
			<rect x="1" y="2" height="1" width="5" />
			<rect x="5" y="1" width="1" height="2" />
			<rect x="4" y="0" width="1" height="1" />
			<rect x="10" y="3" width="1" height="5" />
			<rect x="5" y="8" height="1" width="5" />
			<rect x="5" y="8" width="1" height="2" />
			<rect x="6" y="10" width="1" height="1" />
			<rect x="0" y="10" width="1" height="1" />
			<rect x="1" y="9" width="1" height="1" />
			<rect x="2" y="8" width="1" height="1" />
			<rect x="3" y="7" width="1" height="1" />
			<rect x="4" y="6" width="1" height="1" />
			<rect x="5" y="5" width="1" height="1" />
			<rect x="6" y="4" width="1" height="1" />
			<rect x="7" y="3" width="1" height="1" />
			<rect x="8" y="2" width="1" height="1" />
			<rect x="9" y="1" width="1" height="1" />
			<rect x="10" y="0" width="1" height="1" />
			</svg>`,
		unrepeat: `<svg class="unrepeat" xmlns="http://www.w3.org/2000/svg" width="11" height="11" viewBox="0 0 11 11" preserveAspectRatio="xMidYMid meet" rendering="crispEdges" fill="currentColor" aria-hidden="true">
			<rect x="1" y="8" width="2" height="1"/>
			<rect x="0" y="3" width="1" height="5"/>
			<rect x="1" y="2" width="6" height="1"/>
			<rect x="5" y="1" width="1" height="3"/>
			<rect x="4" y="0" width="1" height="1"/>
			<rect x="4" y="4" width="1" height="1"/>

			<rect x="8" y="2" width="2" height="1"/>
			<rect x="10" y="3" width="1" height="5"/>
			<rect x="4" y="8" width="6" height="1"/>
			<rect x="5" y="7" width="1" height="3"/>
			<rect x="6" y="6" width="1" height="1"/>
			<rect x="6" y="10" width="1" height="1"/>
		</svg>`,
	}, defaultIcons);

	wrapper = document.createElement("div");
	wrapper.classList.add("audiowrapper");

	let audio = document.createElement("audio");
	audio.src = npf.media.url;
	audio.preload = "metadata";
	wrapper.append(audio);
	// #endregion

	// #region Audio information
	let top = document.createElement("div");
	top.classList.add("top");

	let textInfo = document.createElement("div");
	textInfo.classList.add("textinfo");
	if (npf.title) { textInfo.innerHTML += `<span class="trackname">${npf.title}</span>` }
	if (npf.artist) { textInfo.innerHTML += `<span class="artist">${npf.artist}</span>` }
	if (npf.album) { textInfo.innerHTML += `<span class="album">${npf.album}</span>` }
	if (textInfo.childElementCount > 0) { top.append(textInfo) }

	if (npf.poster) {
		let hasArt = document.createElement("div");
		hasArt.classList.add("hasart");
		hasArt.style.setProperty("background-image", `url('${npf.poster[0].url}')`);

		let art = document.createElement("img");
		art.classList.add("albumart");
		art.src = npf.poster[0].url;
		art.width = npf.poster[0].width;
		art.height = npf.poster[0].height;

		top.prepend(art);
		hasArt.append(top);
		wrapper.append(hasArt);
	}
	else if (top.childElementCount > 0 ) {
		wrapper.append(top);
	}
	// #endregion

	// #region Audio controls
	let seekbar = document.createElement("input");
	seekbar.type = "range";
	seekbar.min = 0;
	seekbar.setAttribute("value", "0");
	seekbar.max = 100;
	seekbar.classList.add("seekbar");

	let bottom = document.createElement("div");
	bottom.classList.add("bottom");
	let buttons = document.createElement("div");
	buttons.classList.add("buttons");

	let playPause = document.createElement("button");
	playPause.classList.add("playpause");
	playPause.innerHTML = audicons.play + audicons.pause;
	let currTime = document.createElement("span"),
		totalTime = document.createElement("span");
	currTime.innerText = "0:00";
	totalTime.innerText = "0:00";
	currTime.classList.add("current", "time");
	totalTime.classList.add("total", "time");
	let skipStart = document.createElement("button");
	skipStart.classList.add("skipstart");
	skipStart.innerHTML = audicons.toStart;
	let skipEnd = document.createElement("button");
	skipEnd.classList.add("skipend");
	skipEnd.innerHTML = audicons.toEnd;
	let volume = document.createElement("button");
	volume.classList.add("volume");
	volume.innerHTML = audicons.mute + audicons.unmute;
	let loop = document.createElement("button");
	loop.classList.add("loop");
	loop.innerHTML = audicons.repeat + audicons.unrepeat;

	buttons.append(volume, skipStart, playPause, skipEnd, loop);
	bottom.append(currTime, buttons, totalTime);
	wrapper.append(seekbar, bottom);
	// #endregion

	// #region Preload data and set up interactive elements
	// #region Audio length and ending check
	audio.addEventListener("loadedmetadata", () => {
		seekbar.setAttribute("max", audio.duration);
		totalTime.innerText = calculateTime(audio.duration);
	});
	audio.addEventListener("ended", () => {
		if (!audio.loop) { audio.classList.remove("playing") }
		currentlyPlaying = null;
	})
	// #endregion
	// #region Buttons
	playPause.addEventListener("click", () => {
		// Pause any other audio on the page
		if (currentlyPlaying !== null && currentlyPlaying !== audio) {
			currentlyPlaying.pause();
			currentlyPlaying.classList.remove("playing");
			cancelAnimationFrame(rAF); // in case the previous one had an rAF going on
		}
		// Play/pause current audio as necessary
		if (audio.classList.contains("playing")) {
			currentlyPlaying = null;
			audio.pause();
			cancelAnimationFrame(rAF);
		} else {
			currentlyPlaying = audio;
			audio.play();
			requestAnimationFrame(whilePlaying);
		}
		audio.classList.toggle("playing");
	})
	volume.addEventListener("click", () => {
		audio.muted = !audio.muted;
		volume.classList.toggle("active");
	});
	loop.addEventListener("click", () => {
		audio.loop = !audio.loop;
		loop.classList.toggle("active");
	});
	skipStart.addEventListener("click", () => {
		if (audio.classList.contains("playing")) { audio.pause() }
		audio.currentTime = 0;
		seekbar.value = 0;
		seekbar.style.setProperty("--progress-width", "0%");
		currTime.innerText = "0:00";
		if (audio.classList.contains("playing")) { audio.play() }
	});
	skipEnd.addEventListener("click", () => {
		audio.currentTime = audio.duration;
		seekbar.value = audio.duration;
		seekbar.style.setProperty("--progress-width", "100%");
		currTime.innerText = totalTime.innerText;
		// Fires "ended" by itself
	});
	// #endregion
	// #region Seekbar
	const whilePlaying = () => {
		seekbar.value = Math.floor(audio.currentTime);
		currTime.innerText = calculateTime(seekbar.value);
		seekbar.style.setProperty("--progress-width", `${(audio.currentTime / audio.duration) * 100}%`);
		rAF = requestAnimationFrame(whilePlaying);
	}
	seekbar.addEventListener("input", () => {
		currTime.innerText = calculateTime(seekbar.value);
		if (!audio.paused) {
			cancelAnimationFrame(rAF);
		}
	});
	seekbar.addEventListener("change", () => {
		audio.currentTime = seekbar.value;
		seekbar.style.setProperty("--progress-width", `${(audio.currentTime / audio.duration) * 100}%`);
		currTime.innerText = calculateTime(seekbar.value);
		if (!audio.paused) {
			requestAnimationFrame(whilePlaying);
		}
	});
	// #endregion
	// #endregion

	return wrapper;
}


/** Helper for createCustomAudio. Calculates times and returns it in a MM:SS format.
 * Pulled from https://css-tricks.com/lets-create-a-custom-audio-player/
 * @param {number} secs The number of seconds to be converted.
 * @returns {string} The converted time in minutes and seconds.
 */
function calculateTime(secs) {
	let time = {
		minutes: Math.floor(secs / 60),
		seconds: Math.floor(secs % 60),
	}
	return `${time.minutes}:${time.seconds < 10 ? "0" : ""}${time.seconds}`;
}


/** Renders text block content with inline formatting applied.
 * @param {Object} content The NPF object representing this content block.
 * @param {string} content.text The actual string of text to be displayed in this text block.
 * @param {Object[]} content.formatting An array of objects representing formatting applied to this text block, with start/end indices.
 * @returns An HTML string with inline formatting applied.
 */
function formatText(content) {
	let base = content.text;
	if (!content.formatting)
		return base.replaceAll(String.fromCharCode(10), "<br />");

	let text = "",
		formats = new Array(),
		i = 0;
	// Manually incrementing i instead of a full for-i loop so that emoji unicode combos aren't split up
	for (const char of base) {
		// open any formatting tags
		formats = content.formatting.filter(f => (f.start === i));
		formats.forEach(f => {
			switch (f.type) {
				case "bold":
					text += "<strong>";
					break;
				case "italic":
					text += "<em>";
					break;
				case "small":
					text += "<small>";
					break;
				case "link":
					text += `<a href='${f.url}'>`;
					break;
				case "mention":
					text += `<a href='${f.blog.url}'>`;
					break;
				case "color":
					text += `<span style='color: ${f.hex};'>`;
					break;
			}
		})

		// add the actual character, subbing in linebreaks
		if (char === String.fromCharCode(10)) { text += "<br />" }
		else { text += char }

		// close any formatting tags
		formats = content.formatting.filter(f => (f.end === i + 1));
		formats.forEach(f => {
			switch (f.type) {
				case "bold":
					text += "</strong>";
					break;
				case "italic":
					text += "</em>";
					break;
				case "small":
					text += "</small>";
					break;
				case "link":
					text += "</a>";
					break;
				case "mention":
					text += "</a>";
					break;
				case "color":
					text += "</span>";
					break;
			}
		})

		i ++;
	}
	return text;
}
// #endregion

// #region FOR POST NOTES
/** Creates the Notes section for posts on permalink pages.
 * @param {string} notesURL The URL for the HTML partial of this post's Notes.
 */
function createNotes(notesURL) {
	// Insert separator
	postContainer.append(postSeparator.cloneNode(true));

	// Create base notes section
	let notes = document.createElement("section"),
		header = document.createElement(textSubtypes.heading1);
	notes.id = "notes";
	header.textContent = "{lang:Notes}";
	postContainer.append(notes);

	// Get notes
	var xhttp = new XMLHttpRequest();
	xhttp.onreadystatechange = function(data) {
		if (this.readyState === 4 && this.status === 200) {
			notes.innerHTML = data.srcElement.response;
			cleanNotes();
		}
	}
	xhttp.open("GET", notesURL);
	xhttp.send();

	// Minimize HTML parsing by prepending header after notes partial is added
	notes.prepend(header);
}

/** Cleans newly added notes in the notes section.
 */
function cleanNotes() {
	document.getElementById("notes").querySelectorAll("li:not(.cleaned)").forEach(note => {
		let action = note.querySelector(".action");

		// No cleaning to be done on load more button
		if (note.classList.contains("more_notes_link_container")) { return }

		// Get higher-resolution avatar (16x16 is useless)
		let avatar = note.querySelector("img");
		safeSetAvatar(avatar, `https://api.tumblr.com/v2/blog/${action.firstElementChild.innerText ?? ""}/avatar/64`);
		// ...or remove avatars
		// note.firstChild.remove();

		// Remove clears
		note.querySelector(".clear").remove();

		// Add specific action wrapper
		let acted = document.createElement("span");
		acted.classList.add("acted");
		acted.innerText = action.childNodes[1].textContent;
		action.childNodes[1].replaceWith(acted);

		// Collapse via, addition label into reblog action
		if (note.classList.contains("reblog") && !note.classList.contains("original_post")) {
			action.childNodes[1].append(action.childNodes[2]);
		}
		if (note.classList.contains("with_commentary") && !note.classList.contains("original_post")) {
			action.childNodes[1].append(action.childNodes[2]);
		}

		// Turn reply into blockquote format
		else if (note.classList.contains("reply")) {
			let replyText = document.createElement("blockquote");
			note.append(replyText);
			replyText.innerHTML = Array.from(action.children).at(-1).innerHTML;
			Array.from(action.children).at(-1).remove();
		}

		// Replace [title] with [data-tippy-content]
		note.querySelectorAll("[title]:not([title=''])").forEach(el => {
			el.setAttribute("data-tippy-content", el.title);
			el.removeAttribute("title");
		})

		// Mark note as cleaned
		note.classList.add("cleaned");
	})

	// Create a new singleton tooltip for the full notes section
	notesTooltipInstances = tippy("#notes [data-tippy-content]");
	notesTooltips = tippy.createSingleton(notesTooltipInstances, tippyOptions);
}
/** Removes note tooltips in preparation for new set of notes to be added. */
function tumblrNotesLoaded() {
	// Remove the last singleton and its instances
	notesTooltips?.destroy();
	notesTooltipInstances?.forEach(instance => instance.destroy());
}
/** Cleans up notes and adds tooltips back in. */
function tumblrNotesInserted() { cleanNotes() }
// #endregion

// #region FOR NON-POST PAGES
/** Renders page content on non-post pages.
 * @param {HTMLElement} wrapper The HTML element in which to insert the page content.
 * @param {Object} postData The object containing relevant info with which to populate the page
 * @param {string} postData.title An HTML string containing the title of this page
 * @param {string} postData.body An HTML string containing the body of this page
 */
function createPage(wrapper, postData) {
	let postBody = document.createElement("section");
	postBody.classList.add("body");
	let trailItem = document.createElement("div");
	trailItem.classList.add("bodyitem");
	postBody.append(trailItem);
	wrapper.append(postBody);

	// Create user
	let header = document.createElement("header");
	header.classList.add("user");
	trailItem.append(header);
	// Create permalink
	let link = document.createElement("a");
	link.classList.add("usertext");
	link.href = window.location.href; // gives current URL
	// Get the username and avatar
	let username = document.createElement("span");
	username.classList.add("name");
	username.innerHTML = currentUser.name;
	let avatar = document.createElement("img");
	avatar.classList.add("avatar");
	avatar.src = currentUser.avatar;
	// put together the header
	link.append(icons.question.cloneNode(true), username)
	header.append(link, avatar);

	// Create title and body of page
	// postData.npf is empty; use exclusively .title and .body
	let bodyWrapper = document.createElement("div");
	bodyWrapper.classList.add("bodyitemcontent");
	if (postData.title) {
		let title = document.createElement(textSubtypes.heading1);
		title.innerHTML = unescapeHTML(postData.title);
		bodyWrapper.append(title);
	}
	/*{block:AskPage}{block:IfFAQ}*/
	let faq = document.createElement("div");
	faq.id = "askfaq";
	faq.innerHTML = `{text:FAQ}`;
	bodyWrapper.append(faq);
	/*{/block:IfFAQ}{/block:AskPage}*/
	bodyWrapper.innerHTML += unescapeHTML(postData.body);

	// Plug the whole thing in
	trailItem.append(bodyWrapper);
}

/** Unescapes HTML strings which have quotations, ampersands, or arrow brackets replaced with HTML entities.
 * @param {string} string The escaped HTML string to unescape.
 * @returns An unescaped version of the provided HTML string, fit for adding to innerHTML.
 */
function unescapeHTML(string) {
	return string.replaceAll("&amp;", "&")
				.replaceAll("&#39;", "'")
				.replaceAll("&quot;", "\"")
				.replaceAll("&lt;", "<")
				.replaceAll("&gt;", ">");
}
// #endregion

// #region MISCELLANEOUS HELPERS
/** Rounds a given number and suffixes it with the nearest SI unit.
 * Taken from https://stackoverflow.com/questions/9461621/format-a-number-as-2-5k-if-a-thousand-or-more-otherwise-900#answer-9462382.
 * @param {string|number} num The number, not comma-separated.
 * @param {?number} digits The number of decimal digits to include.
 * @return {string} The truncated number.
 */
function truncateNumber(num, digits = 1) {
	const lookup = [
		{ value: 1, symbol: "" },
		{ value: 1e3, symbol: "k" },
		{ value: 1e6, symbol: "M" },
		{ value: 1e9, symbol: "G" },
		{ value: 1e12, symbol: "T" },
		{ value: 1e15, symbol: "P" },
		{ value: 1e18, symbol: "E" }
	];
	const regexp = /\.0+$|(?<=\.[0-9]*[1-9])0+$/;
	const item = lookup.findLast(item => num >= item.value);
	return item ? (num / item.value).toFixed(digits).replace(regexp, "").concat(item.symbol) : "0";
}

/** Sets an avatar's source URL, falling back to `anonAvatar` if the desired image doesn't load.
 * @param {HTMLImageElement} img The image to set the `src` attribute of.
 * @param {string} url The URL of the desired image.
 */
function safeSetAvatar(img, url) {
	img.addEventListener("error", e => { e.currentTarget.src = anonAvatar }, { once: true });
	img.src = url;
}
//#endregion
// #endregion
</script>

</body>
</html>